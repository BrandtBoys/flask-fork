from __future__ import annotations

import typing as t
from http import HTTPStatus

from flask import Flask
from flask import jsonify
from flask import stream_template
from flask.templating import render_template
from flask.views import View
from flask.wrappers import Response

app = Flask(__name__)


@app.route("/str")
def hello_str() -> str:
    """
Returns an HTML paragraph with 'Hello, World!' as its content.

Args:
None

Returns:
str: The HTML paragraph string.
"""
    return "<p>Hello, World!</p>"


@app.route("/bytes")
def hello_bytes() -> bytes:
    """
Returns a bytes object containing the HTML representation of "Hello, World!".

Args:

None

Returns:

bytes: The bytes object containing the HTML representation of "Hello, World!".

Example:
>>> hello_bytes()
b'<p>Hello, World!</p>'
"""
    return b"<p>Hello, World!</p>"


@app.route("/json")
def hello_json() -> Response:
    """
Returns a JSON response with 'Hello, World!' as its content.

Args:

None

Returns:

Response: A JSON object containing the string "Hello, World!".

Raises:

None
"""
    return jsonify("Hello, World!")


@app.route("/json/dict")
def hello_json_dict() -> dict[str, t.Any]:
    """
Returns a JSON dictionary with a greeting message.

Args:

None

Returns:

A dictionary containing a string response.

Example:
    >>> hello_json_dict()
    {'response': 'Hello, World!'}
"""
    return {"response": "Hello, World!"}


@app.route("/json/dict")
def hello_json_list() -> list[t.Any]:
    return [{"message": "Hello"}, {"message": "World"}]


class StatusJSON(t.TypedDict):
    status: str


@app.route("/typed-dict")
def typed_dict() -> StatusJSON:
    """
Returns a typed dictionary with a 'status' key set to 'ok'.

Args:

None

Returns:

StatusJSON: A dictionary containing a single key-value pair.

Raises:

None
"""
    return {"status": "ok"}


@app.route("/generator")
def hello_generator() -> t.Generator[str, None, None]:
    """
Generates a generator that yields a string with the format "data:<number>\n\n" for 100 iterations.

Returns:
    t.Generator[str, None, None]: A generator that produces strings in the specified format.
"""
    def show() -> t.Generator[str, None, None]:
        """
Generates a sequence of strings representing data points.

Yields:
    A generator that produces strings in the format "data:<int>\n\n" for each integer from 0 to 99.
"""
        for x in range(100):
            yield f"data:{x}\n\n"

    return show()


@app.route("/generator-expression")
def hello_generator_expression() -> t.Iterator[bytes]:
    """
Generates an iterator of bytes containing a 'hello' message repeated 100 times.

Returns:
    Iterator[bytes]: An iterator yielding bytes representing the 'hello' message.
"""
    return (f"data:{x}\n\n".encode() for x in range(100))


@app.route("/iterator")
def hello_iterator() -> t.Iterator[str]:
    """
Returns an iterator that yields 100 lines of data, each on a new line.

The data is generated by concatenating the string "data:" with numbers from 0 to 99,
followed by a newline character. The iterator can be used to process this data in chunks.

Args:
    None

Yields:
    str: A single line of data

Raises:
    None
"""
    return iter([f"data:{x}\n\n" for x in range(100)])


@app.route("/status")
@app.route("/status/<int:code>")
def tuple_status(code: int = 200) -> tuple[str, int]:
    """
Returns a tuple containing a status message and an HTTP status code.

Args:
    code (int): The HTTP status code. Defaults to 200.

Returns:
    tuple[str, int]: A tuple containing the status message and the HTTP status code.
"""
    return "hello", code


@app.route("/status-enum")
def tuple_status_enum() -> tuple[str, int]:
    """
Returns a tuple containing a string and an HTTP status code.

The string is always 'hello', while the HTTP status code is set to OK (200).

Args:

None

Returns:

tuple[str, int]: A tuple containing a string and an HTTP status code.

Raises:

None

Example:
    result = tuple_status_enum()
    print(result)  # Output: ('hello', 200)
"""
    return "hello", HTTPStatus.OK


@app.route("/headers")
def tuple_headers() -> tuple[str, dict[str, str]]:
    """
Returns a tuple containing a string and a dictionary.

The string is 'Hello, World!' and the dictionary contains a single key-value pair with 'Content-Type' as the key and 'text/plain' as the value.

Args:
    None

Returns:
    tuple[str, dict[str, str]]: A tuple containing a string and a dictionary.
"""
    return "Hello, World!", {"Content-Type": "text/plain"}


@app.route("/template")
@app.route("/template/<name>")
def return_template(name: str | None = None) -> str:
    """
Returns an HTML template with a given name.

Args:
    name (str, optional): The name to be displayed in the template. Defaults to None.

Returns:
    str: The rendered HTML template.
"""
    return render_template("index.html", name=name)


@app.route("/template")
def return_template_stream() -> t.Iterator[str]:
    """
Returns an iterator over a template stream.

This function uses the `stream_template` function from the `jinja2` library to generate
an iterator over a template stream. The template is specified by its file path and
name, which are passed as arguments to this function.

Args:
    name (str): The name of the template.

Returns:
    Iterator[str]: An iterator over the lines in the template.
"""
    return stream_template("index.html", name="Hello")


@app.route("/async")
async def async_route() -> str:
    """
Async Route Function

Returns a string indicating that an asynchronous route has been reached.

Args:

None

Returns:

str: A message confirming the presence of an asynchronous route.

Raises:

No exceptions are raised by this function.
"""
    return "Hello"


class RenderTemplateView(View):
    def __init__(self: RenderTemplateView, template_name: str) -> None:
        """
Initializes a new instance of `RenderTemplateView`.

Args:
    template_name (str): The name of the template to render.

Returns:
    None
"""
        self.template_name = template_name

    def dispatch_request(self: RenderTemplateView) -> str:
        """
Dispatches a request to render a template.

This method is responsible for rendering an HTML template using the provided `template_name`. It takes into account the type of view (`self`) and returns the rendered HTML as a string.

Args:
    self (RenderTemplateView): The instance of the RenderTemplateView class.
Returns:
    str: The rendered HTML template.
"""
        return render_template(self.template_name)


app.add_url_rule(
    "/about",
    view_func=RenderTemplateView.as_view("about_page", template_name="about.html"),
)
