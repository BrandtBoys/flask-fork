Success,Comment
"(True, '""""""\nSends a file to the client.\n\nThis function is used to send files from the server to the client. It takes various parameters\nto customize the behavior of the file sending process, such as the MIME type, whether to send\nthe file as an attachment, and the last modified date of the file.\n\nParameters:\n- path_or_file (os.PathLike[t.AnyStr] | str | t.BinaryIO): The path or file-like object containing the data to be sent.\n- mimetype (str | None): The MIME type of the file. Defaults to None.\n- as_attachment (bool): Whether to send the file as an attachment. Defaults to False.\n- download_name (str | None): The name of the downloaded file. Defaults to None.\n- conditional (bool): Whether to check for a conditional GET request. Defaults to True.\n- etag (bool | str): Whether to include the ETag in the response headers or its value as a string. Defaults to True.\n- last_modified (datetime | int | float | None): The last modified date of the file. Defaults to None.\n- max_age (None | (int | t.Callable[[str | None], int | None])): The maximum age of the cached response in seconds. Defaults to None.\n\nReturns:\n- Response: The HTTP response object containing the sent file data.\n""""""')"






"(True, '""""""\nMakes a response for the application.\n\nThis function takes any number of arguments, which are used to construct the response.\nIf no arguments are provided, it returns an empty response. If one argument is provided,\nit is assumed to be a single value and is returned as-is. Otherwise, all arguments\nare passed through to `current_app.make_response()`.\n\nArgs:\n    *args: Any number of values to include in the response (optional)\n\nReturns:\n    Response: The constructed response object\n\nRaises:\n    None\n""""""')"

"(True, '""""""\nValidate the key for a given certificate.\n\nThis function checks if the provided key is valid based on the type of certificate used.\nIt raises an error if the key is not required or if it\'s used with an invalid certificate type.\n\nArgs:\n    ctx (click.Context): The context object containing the command-line arguments.\n    param (click.Parameter): The parameter being validated.\n    value: The value to be validated.\n\nReturns:\n    value: The validated key value.\n\nRaises:\n    click.BadParameter: If the key is not required or if it\'s used with an invalid certificate type.\n""""""')","(True, '""""""\nMakes a response for the application.\n\nThis function takes any number of arguments, which are used to construct the response.\nIf no arguments are provided, it returns an empty response. If one argument is provided,\nit is assumed to be a single value and is returned as-is. Otherwise, all arguments\nare passed through to `current_app.make_response()`.\n\nArgs:\n    *args: Any number of values to include in the response (optional)\n\nReturns:\n    Response: The constructed response object\n\nRaises:\n    None\n""""""')"



"(True, '""""""\nMakes a response for the application.\n\nThis function takes any number of arguments, which are used to construct the response.\nIf no arguments are provided, it returns an empty response. If one argument is provided,\nit is assumed to be a single value and is returned as-is. Otherwise, all arguments\nare passed through to `current_app.make_response()`.\n\nArgs:\n    *args: Any number of values to include in the response (optional)\n\nReturns:\n    Response: The constructed response object\n\nRaises:\n    None\n""""""')"
"(True, '""""""\nMakes a response for the application.\n\nThis function takes any number of arguments, which are used to construct the response.\nIf no arguments are provided, it returns an empty response. If one argument is provided,\nit is assumed to be a single value and is returned as-is. Otherwise, all arguments\nare passed through to `current_app.make_response()`.\n\nArgs:\n    *args: Any number of values to include in the response (optional)\n\nReturns:\n    Response: The constructed response object\n\nRaises:\n    None\n""""""')"
"(True, '""""""\nMakes a response for the application.\n\nThis function takes any number of arguments, which are used to construct the response.\nIf no arguments are provided, it returns an empty response. If one argument is provided,\nit is assumed to be a single value and is returned as-is. Otherwise, all arguments\nare passed through to `current_app.make_response()`.\n\nArgs:\n    *args: Any number of values to include in the response (optional)\n\nReturns:\n    Response: The constructed response object\n\nRaises:\n    None\n""""""')"



"(False, '""""""\nStream a generator or function with context.\n\nThis function takes an iterator or callable that returns an iterator, and wraps it in a context manager. The context manager pushes the current request context onto the stack when the generator is started, and pops it off when the iteration completes.\n\nIf the input is not an iterator, but rather a callable that returns an iterator, this function will wrap the callable in a decorator to create a new function that takes any arguments and returns the wrapped iterator. The `update_wrapper` function is used to preserve the original function\'s name and docstring.\n\nThe context manager uses the `_cv_request.get(None)` method to retrieve the current request context. If no context is available, it raises a RuntimeError.\n\nThis function can only be used when a request context is active, such as in a view function.\n\nArgs:\n    generator_or_function: An iterator or callable that returns an iterator.\n\nReturns:\n    An iterator over the wrapped generator or function.\n""""""\n```')"
"(True, '""""""\nStream a generator or function with context.\n\nThis function takes an iterator or callable that returns an iterator, and wraps it in a context manager. The context manager pushes the current request context onto the stack when the generator is started, and pops it off when the iteration completes.\n\nIf the input is not an iterator, but rather a callable that returns an iterator, this function will wrap the callable in a decorator to create a new function that takes any arguments and returns an iterator. This allows the original function to be used as if it were an iterator.\n\nThe context manager uses the `_cv_request` object to get the current request context, and pushes it onto the stack when the generator is started. When the iteration completes, the context is popped off the stack.\n\nThis function can only be used when a request context is active, such as in a view function.\n\nArgs:\n    generator_or_function: An iterator or callable that returns an iterator.\n\nReturns:\n    An iterator over the results of the input generator or function.\n""""""')","(True, '""""""\nMakes a response for the application.\n\nThis function takes any number of arguments, which are used to construct the response.\nIf no arguments are provided, it returns an empty response. If one argument is provided,\nit is assumed to be a single value and is returned as-is. Otherwise, all arguments\nare passed through to `current_app.make_response()`.\n\nArgs:\n    *args: Any number of values to include in the response (optional)\n\nReturns:\n    Response: The constructed response object\n\nRaises:\n    None\n""""""')","(True, '""""""\nScans a dictionary or list to remove tags.\n\nThis function recursively traverses the input data structure and removes any tags present. It handles both dictionaries and lists, untagging each item within them before returning the modified data structure.\n\nArgs:\n    value (t.Any): The input data structure to be scanned for tags.\n\nReturns:\n    t.Any: The input data structure with all tags removed.\n""""""')","(True, '""""""\nLoads and untags a given string.\n\nThis method takes a string as input, applies the `_untag_scan` function to it, \nand returns the result. The `_untag_scan` function is not defined in this snippet,\nbut it\'s assumed to be a part of the class instance (`self`) that this method belongs to.\n\nArgs:\n    value (str): The input string to be loaded and untagged.\n\nReturns:\n    t.Any: The result of applying `_untag_scan` to the input string.\n""""""')"

"(False, 'def stream_with_context(\n    generator_or_function: t.Iterator[t.AnyStr] | t.Callable[..., t.Iterator[t.AnyStr]],\n) -> t.Iterator[t.AnyStr]:\n    """"""\n    Stream a generator or function with context.\n\n    This function takes an iterator or callable that returns an iterator, and wraps it in a context manager.\n    The context manager pushes the current request context onto the stack when the generator is started,\n    and pops it off when the iteration completes.\n\n    If the input is not an iterator, but rather a callable that returns an iterator,\n    this function will wrap the callable in a decorator to create a new function that takes any arguments\n    and returns an iterator. This allows the original function to be used as if it were an iterator.\n\n    The context manager uses the `_cv_request` object to get the current request context, and pushes it onto the stack when the generator is started.\n    When the iteration completes, the context is popped off the stack.\n\n    This function can only be used when a request context is active, such as in a view function.\n\n    Args:\n        generator_or_function: An iterator or callable that returns an iterator.\n\n    Returns:\n        An iterator over the results of the input generator or function.\n    """"""')","(True, '""""""\nMakes a response for the application.\n\nThis function takes any number of arguments, which are used to construct the response.\nIf no arguments are provided, it returns an empty response. If one argument is provided,\nit is assumed to be a single value and is returned as-is. Otherwise, all arguments\nare passed through to `current_app.make_response()`.\n\nArgs:\n    *args: Any number of values to include in the response (optional)\n\nReturns:\n    Response: The constructed response object\n\nRaises:\n    None\n""""""')"
"(True, '""""""\nAdds a static route to the application using the provided `static_url_path`, \n`static_host`, and `static_folder`. This is done without checking if \n`static_folder` exists, as it might be created while the server is running. \n\nThis method uses a weakref to avoid creating a reference cycle between the app \nand the view function.\n\nArgs:\n    import_name (str): The name of the module being imported.\n    static_url_path (str | None): The URL path for serving static files. Defaults to None.\n    static_folder (str | os.PathLike[str] | None): The folder where static files are stored. Defaults to ""static"".\n    static_host (str | None): The host on which the static route is served. Defaults to None.\n    host_matching (bool): Whether the host should be matched. Defaults to False.\n    subdomain_matching (bool): Whether the subdomain should be matched. Defaults to False.\n    template_folder (str | os.PathLike[str] | None): The folder where templates are stored. Defaults to ""templates"".\n    instance_path (str | None): The path of the instance. Defaults to None.\n    instance_relative_config (bool): Whether the configuration is relative to the instance. Defaults to False.\n    root_path (str | None): The root path of the application. Defaults to None.\n\nRaises:\n    AssertionError: If `static_host` and `host_matching` do not match, or if \n        `static_folder` exists but `static_url_path` is not provided.\n""""""')","(True, '""""""\nReturns the maximum age in seconds for sending files.\n\nIf `filename` is provided, it will be used to retrieve the default send file max age from the application configuration.\nOtherwise, the default value will be returned.\n\nArgs:\n    filename (str | None): The name of the file to retrieve the default send file max age for. If None, the default value will be returned.\n\nReturns:\n    int | None: The maximum age in seconds for sending files, or None if no default value is set.\n""""""')","(True, '""""""\nRaises a routing exception if the current request is not handled by the application.\n\nIf `self.debug` is False or the request does not have a valid redirect, and the redirect\'s code is 307 or 308, or if the request method is GET, HEAD, or OPTIONS, this function raises the original routing exception. Otherwise, it returns a FormDataRoutingRedirect instance for debugging purposes.\n\nArgs:\n    request (Request): The current HTTP request.\n\nReturns:\n    t.NoReturn: This function does not return anything.\n""""""')","(True, '""""""\nUpdates the template context with additional information from request blueprints and context processors.\n\nArgs:\n    context (dict[str, t.Any]): The initial template context to be updated.\n\nReturns:\n    None\n""""""')","(False, 'def make_shell_context(self) -> dict[str, t.Any]:\n    """"""\n    Creates a shell context dictionary by initializing it with the application object and \n    additional data from shell context processors.\n\n    Args:\n        self: The instance of the class that owns this method.\n    \n    Returns:\n        A dictionary containing the application object and any additional data provided by \n        the shell context processors.')","(True, '""""""\nHandles HTTP exceptions by checking their code and routing status.\n\nIf the exception does not have an error code (i.e., it\'s a ProxyException),\nit returns the exception unchanged as an error. If the exception is a RoutingException,\nit also returns it unchanged, as these are internal exceptions used to trigger routing actions.\nOtherwise, it finds an error handler for the exception and calls it with the exception.\n\nArgs:\n    e (HTTPException): The HTTP exception to handle.\nReturns:\n    HTTPException | ft.ResponseReturnValue: The handled exception or a ResponseReturnValue object.\n""""""')","(True, '""""""\nHandles exceptions raised by the application and returns an HTTPException or ResponseReturnValue.\n\nIf a BadRequestKeyError occurs and debug mode or the \'TRAP_BAD_REQUEST_ERRORS\' configuration option is enabled,\nthe exception\'s show_exception attribute is set to True. If an HTTPException occurs but it is not trapped,\nit is handled by the handle_http_exception method. Otherwise, the error handler for the given exception\nis found using the _find_error_handler method and its result is returned.\n\nArgs:\n    e (Exception): The exception to be handled.\nReturns:\n    HTTPException | ResponseReturnValue: The handled exception or response value.\nRaises:\n    Exception: If no error handler can be found for the exception.\n""""""')","(False, 'def dispatch_request(self) -> ft.ResponseReturnValue:\n    """"""\n    Dispatches a request to the corresponding endpoint.\n\n    If automatic options are provided for the URL and the request is an OPTIONS method,\n    it returns a default options response. Otherwise, it calls the view function with\n    the provided view arguments.\n\n    :return: The response from the dispatched view function.\n    """"""')","(True, '""""""\nEnsures that a provided function is synchronous.\n\nIf the function is a coroutine, it is converted to a synchronous function using `async_to_sync`. Otherwise, the original function is returned.\n\nArgs:\n    func (Callable[..., Any]): The function to be ensured as synchronous.\n\nReturns:\n    Callable[..., Any]: The synchronous version of the input function or the original function if it\'s already synchronous.\n""""""')","(True, '""""""\nConverts an asynchronous function to a synchronous one.\n\nThis function takes an asynchronous function as input and returns a new function that can be called synchronously.\nIt uses the `async_to_sync` function from the `asgiref.sync` module, which is part of Flask\'s async support.\n\nIf the required `async` extra for Flask is not installed, a `RuntimeError` is raised with an error message.\n\nArgs:\n    func: The asynchronous function to be converted. It should be a coroutine that takes any number of arguments and returns any type of value.\n\nReturns:\n    A new synchronous function that can be called with the same arguments as the original asynchronous function.\n""""""')","(False, 'def make_response(self, rv: ft.ResponseReturnValue) -> Response:\n    """"""\n    Creates a response object from the given view function result.\n\n    The response object is created based on the type of the view function result.\n    If the result is a tuple, it is unpacked into body, status, and headers.\n    If the result is None, a TypeError is raised.\n    If the result is not an instance of the response class, it is converted to\n    the correct type.\n\n    Args:\n        rv: The view function result.\n\n    Returns:\n        A Response object.\n\n    Raises:\n        TypeError: If the view function did not return a valid response tuple,\n            or if the result is None.\n    """"""')","(True, '""""""\nPreprocesses the request by applying URL value preprocessors and before request functions.\n\nThis method iterates over the blueprint names in reverse order, applying any URL value preprocessors to each one.\nIt then iterates over the same list again, applying any before request functions to each one. If a function returns\na non-None value, it is returned immediately. Otherwise, None is returned at the end.\n\nArgs:\n    self: The instance of the class this method belongs to.\n\nReturns:\n    ft.ResponseReturnValue | None: The result of the preprocess request, or None if no functions return a value.\n""""""')","(True, '""""""\nReturns a new instance of RequestContext with the given WSGI environment.\n\nArgs:\n    environ (WSGIEnvironment): The WSGI environment to use for the context.\n\nReturns:\n    RequestContext: A new instance of RequestContext initialized with the provided environment.\n""""""')","(True, '""""""\nWSGI Application Function.\n\nThis function serves as the entry point for the WSGI application, handling incoming requests and responses.\nIt takes in an environment dictionary (`environ`) and a start response callback (`start_response`), \nand returns an iterable of bytes representing the response to the request.\n\nThe function first creates a request context using `self.request_context(environ)`, which sets up the necessary\ncontext for the application. It then attempts to dispatch the request, handling any exceptions that may occur.\nIf an exception is caught, it is handled by the `handle_exception` method and the response is generated accordingly.\nFinally, the function returns the response, popping the context if no error occurred.\n\nNote: This function uses a try-except block with a bare `except` clause to catch all exceptions. \nThis is generally discouraged in favor of specific exception handling, but may be necessary for compatibility reasons.\n""""""')","(True, '""""""\nCall the wsgi_app method to handle the request.\n\nArgs:\n    environ (WSGIEnvironment): The environment in which the application is running.\n    start_response (StartResponse): A callable that takes a response status code and headers as arguments.\n\nReturns:\n    cabc.Iterable[bytes]: An iterable of bytes representing the response body.\n""""""')","(True, '""""""\nReturns the maximum age in seconds for sending files.\n\nIf `filename` is provided, it will be used to retrieve the default send file max age from the application configuration.\nOtherwise, the default value will be returned.\n\nArgs:\n    filename (str | None): The name of the file to retrieve the default send file max age for. If None, the default value will be returned.\n\nReturns:\n    int | None: The maximum age in seconds for sending files, or None if no default value is set.\n""""""')","(False, 'def find_best_app(module: ModuleType) -> Flask:\n    """"""\n    Finds the best Flask application within a given module.\n\n    The function searches for the most common names (""app"" or ""application"") first.\n    If multiple applications are found, it raises a NoAppException with a message\n    suggesting to use the :name syntax to specify the correct one.\n\n    After searching for named applications, it looks for app factory functions.\n    If a factory function is found and can be called without arguments, it uses\n    that as the application. Otherwise, it raises a NoAppException with a message\n    suggesting to call the factory function with arguments.\n\n    If no Flask application or factory is found, it raises a NoAppException with a\n    message suggesting to use the :name syntax to specify one.\n\n    Args:\n        module (ModuleType): The module to search for the Flask application in.\n\n    Returns:\n        Flask: The best Flask application found in the module.\n\n    Raises:\n        NoAppException: If no Flask application or factory is found.\n    """"""')","(True, '""""""\nChecks if a given Flask function was called with incorrect arguments.\n\nArgs:\n    f (callable): The Flask function to check.\n\nReturns:\n    bool: True if the function was not called with correct arguments, False otherwise.\n""""""')","(False, '```\nFind App by String Function\n==========================\n\n### Purpose\n\nThis function finds an application within a given module based on the provided string.\n\n### Parameters\n\n*   `module`: The module to search for the application.\n*   `app_name`: The name of the application to find.\n\n### Returns\n\nA Flask application object if found, otherwise raises a NoAppException.\n\n### Raises\n\n*   NoAppException: If the application cannot be found or parsed as an attribute name or function call.\n\n### Notes\n\nThis function uses the ast module for parsing and inspect module for checking function types. It also uses getattr to get the attribute from the module and isinstance to check if the attribute is a Flask application object.\n```')","(True, '""""""\nPrepares the import path for a Python module.\n\nThis function takes a file path as input and returns the relative import path\nfor the corresponding module. It handles cases where the input path is within\na package structure, and adjusts the sys.path accordingly.\n\nArgs:\n    path (str): The absolute or relative path to the Python module.\n\nReturns:\n    str: The relative import path for the module.\n""""""')","(True, '""""""\nLocate an application within a given Flask module.\n\nThis function takes in the name of the module and the application to locate,\nas well as an optional parameter to raise an exception if the application is not found.\n\nArgs:\n    - `module_name` (str): The name of the module to search for.\n    - `app_name` (str | None): The name of the application to locate. If None, all applications will be returned.\n    - `raise_if_not_found` (bool, optional): Whether to raise an exception if the application is not found. Defaults to True.\n\nReturns:\n    Flask: The located Flask application object.\n\nRaises:\n    ValueError: If `app_name` is not provided and `raise_if_not_found` is False.\n""""""')","(True, '""""""\nLocate an application within a given module.\n\nThis function searches for an application with the specified name within a given module.\nIt returns the found application or `None` if not found. If `raise_if_not_found` is set to `True`, it raises a `ValueError` if the application is not found.\n\nArgs:\n    - **module_name** (str): The name of the module to search in.\n    - **app_name** (str | None): The name of the application to locate. If `None`, all applications will be returned.\n    - **raise_if_not_found** (bool, optional): Whether to raise an error if the application is not found. Defaults to `False`.\n\nReturns:\n    - Flask | None: The located application or `None` if not found.\n\nRaises:\n    ValueError: If `raise_if_not_found` is set to `True` and the application is not found.\n""""""')","(True, '""""""\nLocate an application within a given module.\n\nThis function attempts to import the specified module and then searches for\nthe requested application. If the application is not found, it will raise a\n`NoAppException`.\n\nArgs:\n    - `module_name`: The name of the module to search in.\n    - `app_name`: The name of the application to locate (optional).\n    - `raise_if_not_found`: Whether to raise an exception if the application\n        is not found. Defaults to True.\n\nReturns:\n    - The located Flask application, or None if no application was found.\n""""""')","(True, '""""""\nReturns the version information of Python, Flask, and Werkzeug.\n\nThis function is used to display the versions of these dependencies when running a Click command.\nIt checks if the value provided is valid (i.e., not empty) or if resilient parsing is enabled,\nin which case it returns without displaying any output. Otherwise, it prints the version information\nto the console using `click.echo` and then exits the application with `ctx.exit()`.\n\nArgs:\n    ctx (click.Context): The Click context object.\n    param (click.Parameter): The parameter being processed.\n    value (t.Any): The value provided by the user.\n\nReturns:\n    None\n""""""')","(True, '""""""\nLoads a Flask application instance.\n\nThis method attempts to load an existing Flask application from the `self._loaded_app` attribute,\nor creates a new one if none exists. It also sets the debug flag of the loaded application\nif `self.set_debug_flag` is True.\n\nIf no application can be found, it raises a `NoAppException`.\n\nReturns:\n    Flask: The loaded or created Flask application instance.\n""""""')","(True, '""""""\nDecorates a function to run with the application context.\n\nThis decorator is used to ensure that functions decorated with it are executed within\nthe application\'s context. This can be useful for tasks such as database operations,\nfile I/O, or any other operation that requires access to the current application state.\n\nThe `with_appcontext` function takes a function `f` as an argument and returns the result of\ninvoking `f` with the application context. If the application context is not already set,\nit will load the application from the `ScriptInfo` object associated with the click context.\n\nArgs:\n    f (function): The function to be decorated.\n\nReturns:\n    function: The original function, wrapped in a decorator that runs it with the application context.\n""""""')","(True, '""""""\nDecorates a function with the necessary context.\n\nThis decorator loads the application context and ensures that it is available for the decorated function.\nIf the current application context is not set, it loads the script info from the click context and switches to its app context.\n\nArgs:\n    ctx (click.Context): The click context object.\n    /: Ignored positional argument.\n    *args (t.Any): Variable number of non-keyword arguments.\n    **kwargs (t.Any): Variable number of keyword arguments.\n\nReturns:\n    t.Any: The result of the decorated function invocation.\n""""""')","(False, '""""""\nDecorates a function to create a Click command.\n\nThis decorator wraps the provided function in a Click command. It allows for optional wrapping of the function with an application context.\n\nArgs:\n    f (callable): The function to be decorated as a Click command.\n\nReturns:\n    click.Command: A Click command instance wrapped around the provided function.\n""""""\ndef command(*args: t.Any, **kwargs: t.Any) -> t.Callable[[t.Callable[..., t.Any]], click.Command]:\n    wrap_for_ctx = kwargs.pop(""with_appcontext"", True)\n\n    def decorator(f: t.Callable[..., t.Any]) -> click.Command:\n        if wrap_for_ctx:\n            f = with_appcontext(f)\n        return super(AppGroup, self).command(*args, **kwargs)(f)  # type: ignore[no-any-return]\n\n    return decorator')","(True, '""""""\nDecorates a function to create a Click command.\n\nThis decorator wraps the provided function in an AppGroup context if `wrap_for_ctx` is True.\nIt then calls the `super()` method on the AppGroup class, passing the original function as an argument,\nand returns the result of this call. The `# type: ignore[no-any-return]` comment suppresses a type check warning.\n\nArgs:\n    f (t.Callable[..., t.Any]): The function to be decorated.\n\nReturns:\n    click.Command: The decorated Click command.\n""""""')","(False, 'def group(\n    """"""\n    Creates a new instance of the `click.Group` class.\n\n    This method is overridden to set the default value for the \'cls\' keyword argument\n    to `AppGroup`, which is assumed to be a subclass of `click.Group`.\n\n    Args:\n        *args: Variable length argument list.\n        **kwargs: Arbitrary keyword arguments.\n\n    Returns:\n        A new instance of the `click.Group` class, or a callable that returns one.\n    """"""\n) -> t.Callable[[t.Callable[..., t.Any]], click.Group]:\n    kwargs.setdefault(""cls"", AppGroup)\n    return super().group(*args, **kwargs)  # type: ignore[no-any-return]')","(True, '""""""\nLoads plugin commands from the `importlib.metadata` module.\n\nThis method checks if plugin commands have already been loaded and returns early.\nIf the Python version is 3.10 or higher, it uses the `metadata` function from `importlib`.\nOtherwise, it uses a backport of `importlib_metadata` for consistency with earlier versions.\nIt then iterates over the entry points in the ""flask.commands"" group and adds each command to the instance\'s commands.\n\nArgs:\n    None\n\nReturns:\n    None\n""""""')","(True, '""""""\nReturns the specified command from the application\'s CLI.\n\nIf the command is found in the built-in commands or plugin commands,\nit returns that command. Otherwise, it attempts to load the\napplication and retrieve the command from its CLI.\n\nIf the application fails to load, an error message is displayed\nand `None` is returned.\n\nArgs:\n    ctx (click.Context): The context of the current command.\n    name (str): The name of the command to retrieve.\n\nReturns:\n    click.Command | None: The specified command or `None` if not found.\n""""""')","(True, '""""""\nLists all available commands for a given context.\n\nThis function extends the base command listing functionality by also including\ncommands provided by plugins and apps. If an app couldn\'t be loaded, it will\ndisplay an error message without the traceback. Any other errors during loading\nwill display the full traceback.\n\nArgs:\n    ctx (click.Context): The context in which to list commands.\n\nReturns:\n    list[str]: A sorted list of all available commands.\n""""""')","(False, '""""""\nReturns True if `other` is an ancestor of `path`, False otherwise.\n\nThis function checks if the path `other` is a prefix of `path`. It does this by joining `path` and `other` with the appropriate separator, then comparing the result to `other`.\n\nArgs:\n    path (str): The base path.\n    other (str): The potential ancestor path.\n\nReturns:\n    bool: True if `other` is an ancestor of `path`, False otherwise.')","(True, '""""""\nLoads environment variables from a .env or .flaskenv file.\n\nIf no specific path is provided, it will attempt to load the default files\nin the current working directory. If neither a specific path nor default\nfiles are found, it will print a tip message suggesting installing python-dotenv.\n\nArgs:\n    path (str | os.PathLike[str] | None): The path to the .env or .flaskenv file.\n        If None, it will attempt to load the default files in the current working directory.\n\nReturns:\n    bool: True if at least one file was located and loaded, False otherwise.\n""""""')","(True, '""""""\nShow server banner based on debug mode and application import path.\n\nThis function displays a banner indicating whether the application is being served\nand, if so, its import path. It also indicates whether debug mode is enabled.\n\nArgs:\n    - debug (bool): Whether to display debug mode information.\n    - app_import_path (str | None): The path to the imported Flask application.\n\nReturns:\n    None\n""""""')","(True, '""""""\nInitialize a new instance of the class.\n\nThis method initializes an empty instance with a path type attribute.\nThe path type is set to require an existing file path that cannot be a directory,\nand will attempt to resolve the path if possible.\n\nAttributes:\n    path_type (click.Path): The path type attribute of this instance.\n""""""')","(True, '""""""\nConverts a given value to its corresponding type.\n\nThis function attempts to convert the provided `value` into its respective type.\nIf the conversion fails, it tries to parse the `value` as a string and then checks if it\'s an ad-hoc certificate or an SSL context.\n\nArgs:\n    self: The instance of the class that this method belongs to.\n    value (t.Any): The value to be converted.\n    param (click.Parameter | None): The parameter associated with the conversion.\n    ctx (click.Context | None): The context in which the conversion is taking place.\n\nReturns:\n    t.Any: The converted value.\n\nRaises:\n    click.BadParameter: If the conversion fails or if a required library is not installed.\n""""""')","(True, '""""""\nValidate the key for a given certificate.\n\nThis function checks if the provided key is valid based on the type of certificate used.\nIt raises an error if the key is not required or if it\'s used with an invalid certificate type.\n\nArgs:\n    ctx (click.Context): The context object containing the command-line arguments.\n    param (click.Parameter): The parameter being validated.\n    value: The value to be validated.\n\nReturns:\n    value: The validated key value.\n\nRaises:\n    click.BadParameter: If the key is not required or if it\'s used with an invalid certificate type.\n""""""')","(False, 'def convert(self, value: t.Any, param: click.Parameter | None, ctx: click.Context | None) -> t.Any:\n    """"""\n    Converts a given environment variable value into a list of converted values.\n\n    This method splits the input value by the environment variable separator and then\n    converts each resulting item using the parent class\'s convert method.\n\n    Args:\n        value (t.Any): The environment variable value to be converted.\n        param (click.Parameter | None): The parameter object associated with this command.\n        ctx (click.Context | None): The context object for this command invocation.\n\n    Returns:\n        t.Any: A list of converted values.\n    """"""')","(False, 'def run_command(\n    """"""\n    Runs a command with the specified configuration.\n\n    Parameters:\n    - info (ScriptInfo): Information about the script to be executed.\n    - host (str): The hostname or IP address of the server.\n    - port (int): The port number of the server.\n    - reload (bool): Whether to enable reloading. If None, uses the debug flag.\n    - debugger (bool): Whether to enable debugging. If None, uses the debug flag.\n    - with_threads (bool): Whether to run in threaded mode.\n    - cert (ssl.SSLContext | tuple[str, str | None] | t.Literal[""adhoc""] | None): The SSL context or certificate information.\n    - extra_files (list[str] | None): A list of additional files to include.\n    - exclude_patterns (list[str] | None): A list of patterns to exclude.\n\n    Returns:\n    None\n    """"""\n    try:\n        app: WSGIApplication = info.load_app()\n    except Exception as e:\n        if is_running_from_reloader():\n            # When reloading, print out the error immediately, but raise\n            # it later so the debugger or server can handle it.\n            traceback.print_exc()\n            err = e\n\n            def app(\n                environ: WSGIEnvironment, start_response: StartResponse\n            ) -> cabc.Iterable[bytes]:\n                raise err from None\n\n        else:\n            # When not reloading, raise the error immediately so the\n            # command fails.\n            raise e from None\n\n    debug = get_debug_flag()\n\n    if reload is None:\n        reload = debug\n\n    if debugger is None:\n        debugger = debug\n\n    show_server_banner(debug, info.app_import_path)\n\n    run_simple(\n        host,\n        port,\n        app,\n        use_reloader=reload,\n        use_debugger=debugger,\n        threaded=with_threads,\n        ssl_context=cert,\n        extra_files=extra_files,\n        exclude_patterns=exclude_patterns,\n    )')","(True, '""""""\nWSGI Application Function.\n\nThis function serves as the entry point for a web application. It takes in an environment object and a response object,\nand returns an iterable of bytes.\n\nRaises:\n    err: An exception to be raised when the application is unable to handle the request.\n""""""')","(True, '""""""\nRun a Python shell with customized banner and interactive hook.\n\nThis function sets up a Python shell with a custom banner displaying the\nPython version, platform, application name, and instance path. It also\nsupports setting an interactive hook to customize the readline experience,\nsuch as tab completion.\n\nArgs:\n    None\n\nReturns:\n    None\n""""""')","(True, '""""""\nInitialize a new instance of the class.\n\nArgs:\n    - **name (str)**: The name of the converter.\n    - **get_converter (t.Callable[[t.Any], T] | None, optional)**: A function that converts any type to the target type. Defaults to None.\n\nReturns:\n    None\n""""""')","(False, '""""""\nGets an attribute from the instance.\n\nThis method is a special method in Python classes that allows you to define getter methods for attributes. It takes three parameters:\n\n- `self`: The instance of the class.\n- `obj`: The object being accessed (usually the instance itself).\n- `owner`: The owner of the attribute (not used in this implementation).\n\nReturns an instance of `te.Self` representing the attribute value.\n\nNote:\n    This method is typically used as a property decorator to define getter methods for attributes.')","(True, '""""""\nGets an attribute from an instance of the class.\n\nThis method is used to implement property access in Python. It allows you to define a getter function for a property and use it with the `@property` decorator.\n\nArgs:\n    self (object): The instance of the class.\n    obj (App, optional): The object that owns this attribute. Defaults to None.\n    owner (type[App], optional): The type of the App class. Defaults to None.\n\nReturns:\n    T: The value of the attribute.\n""""""')","(True, '""""""\nGets the configuration value for this descriptor.\n\nIf `obj` is provided, it must be an instance of `App`. The method returns\nthe configuration value associated with the name of this descriptor. If a\nconverter function is set on this descriptor, it will be applied to the\nconfiguration value before being returned.\n\nArgs:\n    obj: An instance of App (optional)\n    owner: The type of the App instance (optional)\n\nReturns:\n    T | te.Self: The configuration value or self if no object was provided.\n""""""')","(True, '""""""\nSets a configuration attribute on an object.\n\nThis method is used to set a configuration attribute on an object. The attribute name is determined by the `__name__` attribute of the current instance, and its value is stored in the `config` dictionary of the object\'s parent class (`App`). \n\nArgs:\n    obj (App): The object that owns this configuration attribute.\n    value (t.Any): The new value for the configuration attribute.\n\nReturns:\n    None\n""""""')","(True, '""""""\nInitialize the documentation assistant.\n\n### Parameters\n\n- **root_path**: The root path of the documentation. Can be a string or an os.PathLike object.\n- **defaults**: An optional dictionary of default values to use for initialization. Defaults to None.\n\n### Returns\n\nNone\n""""""')","(True, '""""""\nLoads a configuration from a Python file.\n\nThis function reads the contents of a specified Python file, executes it as a module,\nand then calls `from_object` on the resulting object. If the file does not exist or\ncannot be executed for some reason, an error is raised.\n\nArgs:\n    filename (str | os.PathLike[str]): The path to the configuration file.\n    silent (bool): If True, returns False if the file cannot be loaded without raising an exception. Defaults to False.\n\nReturns:\n    bool: Whether the configuration was successfully loaded.\n""""""')","(True, '""""""\nLoads a configuration file from disk.\n\nThis method attempts to open the specified file and load its contents using the provided\n`load` function. If successful, it returns `True`. Otherwise, it raises an exception with a\ncustomized error message if silent mode is enabled or returns `False`.\n\nArgs:\n    filename (str | os.PathLike[str]): The path to the configuration file.\n    load (t.Callable[[t.IO[t.Any]], t.Mapping[str, t.Any]]): A function that takes an IO object and returns a mapping of key-value pairs.\n    silent (bool, optional): If True, exceptions are caught silently. Defaults to False.\n    text (bool, optional): Specifies whether the file should be opened in text mode (True) or binary mode (False). Defaults to True.\n\nReturns:\n    bool: Whether the configuration was loaded successfully.\nRaises:\n    OSError: If an error occurs while loading the configuration file.\n""""""')","(True, '""""""\nReturns a decorator that appends the provided callable to the list of functions \nto be executed after the current request has been completed.\n\nArgs:\n    f (ft.AfterRequestCallable[t.Any]): The callable to be appended to the list.\n\nReturns:\n    ft.AfterRequestCallable[t.Any]: The decorated function.\nRaises:\n    RuntimeError: If no request context is active, indicating that \'after_this_request\' \n                  can only be used when a request context is active, such as in a view function.\n""""""')","(False, 'def copy_current_request_context(f: F) -> F:\n    """"""\n    Copies the current request context to a new context.\n\n    This function is used in view functions to ensure that the request context\n    is preserved across multiple calls. It raises an error if no request context\n    is active, as required by the WSGI specification.\n\n    Args:\n        f: The function to decorate with the copied request context.\n\n    Returns:\n        A new version of the input function with the copied request context.\n    """"""')","(False, '""""""\nWrapper function to ensure synchronous execution of the application.\n\nThis function takes in variable arguments and keyword arguments, \nand returns the result of the application\'s `ensure_sync` method.\n\nArgs:\n    *args (t.Any): Variable positional arguments.\n    **kwargs (t.Any): Variable keyword arguments.\n\nReturns:\n    t.Any: The result of the application\'s `ensure_sync` method.\n""""""\ndef wrapper(*args: t.Any, **kwargs: t.Any) -> t.Any:\n    with ctx:  # type: ignore[union-attr]\n        return ctx.app.ensure_sync(f)(*args, **kwargs)  # type: ignore[union-attr]')","(True, '""""""\nInitializes the documentation assistant with a Flask application instance.\n\nArgs:\n    app (Flask): The Flask application instance to be used for URL adaptation and context management.\n\nReturns:\n    None\n""""""')","(True, '""""""\nInitialize a new instance of the class.\n\nThis method is called when an object of this class is instantiated. It takes in several parameters:\n\n- `app`: The Flask application instance.\n- `environ`: The WSGI environment.\n- `request`: An optional request object, defaults to None.\n- `session`: An optional session mixin object, defaults to None.\n\nThe method initializes the internal state of the class by setting up the request object and creating a URL adapter if possible. It also sets up the flash messages and session objects.\n\nAfter initialization, any functions that should be executed after the request on the response object can be added to the `_after_request_functions` list.\n\nParameters:\napp (Flask): The Flask application instance.\nenviron (WSGIEnvironment): The WSGI environment.\nrequest (Request | None): An optional request object. Defaults to None.\nsession (SessionMixin | None): An optional session mixin object. Defaults to None.\n\nReturns:\nNone\n""""""')","(False, '""""""\nInitialize the documentation assistant.\n\nThis function is called when an instance of the class is created.\nIt takes in a request object and a key as parameters, \nand sets up the necessary data for the class to function correctly.\n\nParameters:\n    request (Request): The HTTP request object containing information about the incoming request.\n    key (str): The key associated with the file being accessed.\n\nReturns:\n    None\n""""""\ndef __init__(self, request: Request, key: str) -> None:')","(False, '""""""\nReturns a string representation of the object.\n\nThis method is used to provide a human-readable representation of the object.\nIt should be overridden by subclasses to provide a meaningful string value.\n\nArgs:\n    None\n\nReturns:\n    str: A string representation of the object\'s message.')","(True, '""""""\nRaises a custom exception when a request is redirected by the router.\n\nThis exception is raised when a request is sent to a URL that is\nredirected by the router, but the redirect was not properly configured.\nThe exception provides information about the original and canonical URLs,\nas well as guidance on how to configure routing redirects correctly.\n\nIn debug mode only. In production mode, this exception will be caught\nand handled by Flask\'s default error handling mechanism.\n\nParameters:\n    request (Request): The original request that caused the redirect.\n\nReturns:\n    None\n\nRaises:\n    RequestRedirect: A custom exception with information about the redirect.\n""""""')","(True, '""""""\nReplaces the default behavior of Django\'s `request.files` with a multidict-based implementation.\n\nWhen an error occurs while accessing a file, it will be raised as a `DebugFilesKeyError` instead of raising a `KeyError`. This allows for additional debugging information to be provided.\n\nThis function is intended to be used in conjunction with the `django.http.HttpRequest` class. It should not be called directly by external code.\n\nArgs:\n    request (HttpRequest): The HTTP request object.\n\nReturns:\n    None\n""""""')","(True, '""""""\nRaises a `DebugFilesKeyError` exception when the provided key is not found in the request form.\nIf the key is present but raises a KeyError, it will be re-raised with additional context.\n\nArgs:\n    key (str): The key to look up in the request form.\n\nReturns:\n    t.Any: The value associated with the key if found, otherwise raises an exception.\n\nRaises:\n    DebugFilesKeyError: If the key is not found in the request form.\n    KeyError: If the key is present but raises a KeyError.\n""""""')","(True, '""""""\nYields a formatted string representation of the loader\'s class and attributes.\n\nThis function takes a `BaseLoader` object as input and returns an iterator over strings.\nEach string represents either a class or attribute of the loader, with indentation used to denote nested values.\n\nThe yielded strings are formatted according to the following rules:\n- Class information is represented as ""class: <module>.<class_name>"".\n- Attribute values that are tuples or lists are indented and separated by hyphens (e.g. ""key: value1 - value2"").\n- Attribute values that are not strings, integers, floats, or booleans are skipped.\n\nArgs:\n    loader (BaseLoader): The loader object to generate documentation for.\n\nYields:\n    str: A formatted string representation of the loader\'s class and attributes.\n""""""')","(False, 'def explain_template_loading_attempts(\n    app: App,\n    template: str,\n    attempts: list[\n        tuple[\n            BaseLoader,\n            Scaffold,\n            tuple[str, str | None, t.Callable[[], bool] | None] | None,\n        ]\n    ],\n) -> None:\n    """"""\n    Logs the process of loading a template in an application.\n\n    This function takes an application object, a template name, and a list of\n    attempts to load the template. It logs each attempt\'s details, including any\n    matches found or errors encountered.\n\n    Args:\n        app: The application object.\n        template: The name of the template to be loaded.\n        attempts: A list of tuples containing the loader, source object, and triple\n            (match detail) for each attempt.\n\n    Returns:\n        None\n    """"""\n    info = [f""Locating template {template!r}:""]\n    total_found = 0\n    blueprint = None\n\n    if request_ctx and request_ctx.request.blueprint is not None:\n        blueprint = request_ctx.request.blueprint\n\n    for idx, (loader, srcobj, triple) in enumerate(attempts):\n        if isinstance(srcobj, App):\n            src_info = f""application {srcobj.import_name!r}""\n        elif isinstance(srcobj, Blueprint):\n            src_info = f""blueprint {srcobj.name!r} ({srcobj.import_name})""\n        else:\n            src_info = repr(srcobj)\n\n        info.append(f""{idx + 1:5}: trying loader of {src_info}"")\n\n        for line in _dump_loader_info(loader):\n            info.append(f""       {line}"")\n\n        if triple is None:\n            detail = ""no match""\n        else:\n            detail = f""found ({triple[1] or \'<string>\'!r})""\n            total_found += 1\n        info.append(f""       -> {detail}"")\n\n    seems_fishy = False\n    if total_found == 0:\n        info.append(""Error: the template could not be found."")\n        seems_fishy = True\n    elif total_found > 1:\n        info.append(""Warning: multiple loaders returned a match for the template."")\n        seems_fishy = True\n\n    if blueprint is not None and seems_fishy:\n        info.append(\n            ""  The template was looked up from an endpoint that belongs""\n            f"" to the blueprint {blueprint!r}.""\n        )\n        info.append(""  Maybe you did not place a template in the right folder?"")\n        info.append(""  See https://flask.palletsprojects.com/blueprints/#templates"")\n\n    app.logger.info(""\\n"".join(info))')","(False, 'def stream_with_context(\n    generator_or_function: t.Iterator[t.AnyStr] | t.Callable[..., t.Iterator[t.AnyStr]]\n) -> t.Iterator[t.AnyStr]:\n    """"""\n    Stream a generator or function with context.\n\n    This function takes an iterator or callable that returns an iterator, and wraps it in a context manager.\n    The context manager pushes the current request context onto the stack when the generator is started,\n    and pops it off when the iteration completes.\n\n    If the input is not an iterator, but rather a callable that returns an iterator,\n    this function will wrap the callable in a decorator to create a new function that takes any arguments\n    and returns an iterator. This allows the original function to be used as if it were an iterator.\n\n    The context manager uses the `_cv_request` object to get the current request context, and pushes it onto the stack when the generator is started.\n    When the iteration completes, the context is popped off the stack.\n\n    This function can only be used when a request context is active, such as in a view function.\n\n    Args:\n        generator_or_function: An iterator or callable that returns an iterator.\n\n    Returns:\n        An iterator over the results of the input generator or function.\n    """"""')","(True, '""""""\nDecorates a function or generator with the `stream_with_context` function from the `itertools` module.\n\nArgs:\n    *args (t.Any): Variable number of positional arguments to be passed to the decorated function or generator.\n    **kwargs (t.Any): Variable number of keyword arguments to be passed to the decorated function or generator.\n\nReturns:\n    t.Any: The result of applying the `stream_with_context` function to the provided function or generator.\n\nNote:\n    This decorator is used to convert a function or generator into an iterator that can be used with the `stream_with_context` function.\n""""""')","(False, '""""""\nGenerates a generator iterator with a dummy sentinel and cleanup logic.\n\nRaises a RuntimeError if \'stream_with_context\' is used without an active request context.\n\nYields:\n    t.AnyStr | None: A dummy sentinel value or None.\n""""""\ndef generator() -> t.Iterator[t.AnyStr | None]:')","(False, 'def send_from_directory(\n    """"""\n    Sends a file from the specified directory.\n\n    Args:\n        directory (os.PathLike[str] | str): The path to the directory containing the file.\n        path (os.PathLike[str] | str): The path to the file within the directory.\n        **kwargs: Additional keyword arguments to be passed to werkzeug.utils.send_from_directory.\n\n    Returns:\n        Response: A response object containing the sent file.\n\n    Raises:\n        ValueError: If the provided directory or path is invalid.\n    """"""\n    return werkzeug.utils.send_from_directory(  # type: ignore[return-value]\n        directory, path, **_prepare_send_file_kwargs(**kwargs)\n    )')","(True, '""""""\nReturns the root path of the given imported module.\n\nIf the module has already been imported and its file attribute is available,\nits directory path is returned. Otherwise, it attempts to find the loader\nassociated with the import specification and uses it to determine the root\npath. If this fails, it falls back to using the current working directory.\n\nArgs:\n    import_name (str): The name of the module for which to retrieve the root path.\n\nReturns:\n    str: The root path of the given imported module.\nRaises:\n    ValueError: If the loader is not found or if the module specification is None.\n    RuntimeError: If no root path can be found for a namespace package.\n""""""')","(True, '""""""\nReturns a JSON response.\n\nThis function takes in any number of positional arguments and keyword arguments,\nwhich are then passed to the `json` method of the current application instance.\nThe result is a JSON response object.\n\nArgs:\n    *args (t.Any): Any positional arguments to be included in the response.\n    **kwargs (t.Any): Any keyword arguments to be included in the response.\n\nReturns:\n    Response: A JSON response object.\n""""""')","(False, '""""""\nInitializes the object with a reference to an application instance.\n\nArgs:\n    app (App): The application instance to be referenced.\n\nReturns:\n    None\n""""""\ndef __init__(self, app: App) -> None:\n    """"""\n    Initializes the object with a weak reference to the provided application instance.\n    \n    This allows for efficient garbage collection of the original application instance,\n    while still maintaining access to its attributes through this proxy object.\n    """"""\n    self._app: App = weakref.proxy(app)')","(True, '""""""\nConverts a given value to JSON format and returns it as a dictionary.\n\nArgs:\n    value (t.Any): The value to be converted to JSON format.\n\nReturns:\n    dict[str, t.Any]: A dictionary containing the key-value pair where the key is \'tag\' and the value is the JSON representation of the input value.\n""""""')","(True, '""""""\nRegisters a new JSON tag or inserts an existing one at the specified position in the order list.\n\nArgs:\n    - `tag_class`: The class of the JSON tag to be registered.\n    - `force` (optional): If True, forces registration even if the key already exists. Defaults to False.\n    - `index` (optional): The index at which to insert the tag. If None, appends to the end of the order list.\n\nRaises:\n    KeyError: If the key is already registered and force is False.\n\nReturns:\n    None\n""""""')","(True, '""""""\nReturns the first matching tag from the order list.\n\nIf a match is found, it returns the corresponding tag\'s value. Otherwise, it returns the original input value.\n\nArgs:\n    value (t.Any): The input value to be checked against the tags.\n\nReturns:\n    t.Any: The matched tag\'s value or the original input value.\n""""""')","(False, '""""""\nReturns a TextIO object that can be used to stream WSGI error messages.\n\nIf the `request` object is available, it returns the `wsgi.errors` attribute of the request environment.\nOtherwise, it falls back to printing to the standard error stream (`sys.stderr`). \n\nThis function is intended for use in web frameworks that support WSGI, such as Django or Pyramid.')","(False, '""""""\nInitializes a new Flask application instance.\n\nThis function is used to create a new Flask application. It takes several keyword arguments that define various aspects of the application, such as its import name, static folder path, and template folder path.\n\nThe `__init__` method initializes the Flask application by calling the parent class\'s `__init__` method with some default values. Then it checks if an instance path is provided and sets it to a default value or raises an error if it\'s not absolute.\n\nIt also initializes several attributes, including:\n\n- `instance_path`: The path to the instance folder.\n- `config`: A configuration dictionary that can be used to load a config from files.\n- `aborter`: An aborter object that is called by `flask.abort` to raise HTTP errors.\n- `json`: A JSON provider object that provides access to JSON methods.\n- `url_build_error_handlers`: A list of functions that are called when the application context is destroyed.\n- `teardown_appcontext_funcs`: A list of shell context processor functions that should be run when a shell context is created.\n- `shell_context_processors`: A list of blueprint names mapped to blueprint objects.\n- `blueprints`: A dictionary that maps registered blueprint names to blueprint objects.\n- `extensions`: A dictionary where extensions can store application-specific state.\n- `url_map`: The URL map for this instance.\n\nThe default provider class is the `DefaultJSONProvider` which uses Python\'s built-in JSON library. The default aborter class is the `Aborter` class which raises HTTP errors.\n\n.. versionadded:: 0.8\n""""""\n\n""""""\nInitializes a new Flask application instance with custom configuration.\n\nThis function is used to create a new Flask application with custom configuration. It takes several keyword arguments that define various aspects of the application, such as its import name, static folder path, and template folder path.\n\nThe `__init__` method initializes the Flask application by calling the parent class\'s `__init__` method with some default values. Then it checks if an instance path is provided and sets it to a default value or raises an error if it\'s not absolute.\n\nIt also initializes several attributes, including:\n\n- `instance_path`: The path to the instance folder.\n- `config`: A configuration dictionary that can be used to load a config from files.\n- `aborter`: An aborter object that is called by `flask.abort` to raise HTTP errors.\n- `json`: A JSON provider object that provides access to JSON methods.\n- `url_build_error_handlers`: A list of functions that are called when the application context is destroyed.\n- `teardown_appcontext_funcs`: A list of shell context processor functions that should be run when a shell context is created.\n- `shell_context_processors`: A list of blueprint names mapped to blueprint objects.\n- `blueprints`: A dictionary that maps registered blueprint names to blueprint objects.\n- `extensions`: A dictionary where extensions can store application-specific state.\n- `url_map`: The URL map for this instance.\n\nThe default provider class is the `DefaultJSONProvider` which uses Python\'s built-in JSON library. The default aborter class is the `Aborter` class which raises HTTP errors.\n\n.. versionadded:: 2.2\n""""""\n\n""""""\nInitializes a new Flask application instance with custom configuration and blueprint registration.\n\nThis function is used to create a new Flask application with custom configuration and blueprint registration. It takes several keyword arguments that define various aspects of the application, such as its import name, static folder path, and template folder path.\n\nThe `__init__` method initializes the Flask application by calling the parent class\'s `__init__` method with some default values. Then it checks if an instance path is provided and sets it to a default value or raises an error if it\'s not absolute.\n\nIt also initializes several attributes, including:\n\n- `instance_path`: The path to the instance folder.\n- `config`: A configuration dictionary that can be used to load a config from files.\n- `aborter`: An aborter object that is called by `flask.abort` to raise HTTP errors.\n- `json`: A JSON provider object that provides access to JSON methods.\n- `url_build_error_handlers`: A list of functions that are called when the application context is destroyed.\n- `teardown_appcontext_funcs`: A list of shell context processor functions that should be run when a shell context is created.\n- `shell_context_processors`: A list of blueprint names mapped to blueprint objects.\n- `blueprints`: A dictionary that maps registered blueprint names to blueprint objects.\n- `extensions`: A dictionary where extensions can store application-specific state.\n- `url_map`: The URL map for this instance.\n\nThe default provider class is the `DefaultJSONProvider` which uses Python\'s built-in JSON library. The default aborter class is the `Aborter` class which raises HTTP errors.\n\n.. versionadded:: 0.7\n""""""\n\n""""""\nInitializes a new Flask application instance with custom configuration and blueprint registration, and sets up extensions.\n\nThis function is used to create a new Flask application with custom configuration and blueprint registration, and sets up extensions. It takes several keyword arguments that define various aspects of the application, such as its import name, static folder path, and template folder path.\n\nThe `__init__` method initializes the Flask application by calling the parent class\'s `__init__` method with some default values. Then it checks if an instance path is provided and sets it to a default value or raises an error if it\'s not absolute.\n\nIt also initializes several attributes, including:\n\n- `instance_path`: The path to the instance folder.\n- `config`: A configuration dictionary that can be used to load a config from files.\n- `aborter`: An aborter object that is called by `flask.abort` to raise HTTP errors.\n- `json`: A JSON provider object that provides access to JSON methods.\n- `url_build_error_handlers`: A list of functions that are called when the application context is destroyed.\n- `teardown_appcontext_funcs`: A list of shell context processor functions that should be run when a shell context is created.\n- `shell_context_processors`: A list of blueprint names mapped to blueprint objects.\n- `blueprints`: A dictionary that maps registered blueprint names to blueprint objects.\n- `extensions`: A dictionary where extensions can store application-specific state.\n- `url_map`: The URL map for this instance.\n\nThe default provider class is the `DefaultJSONProvider` which uses Python\'s built-in JSON library. The default aborter class is the `Aborter` class which raises HTTP errors.\n\n.. versionadded:: 0.7\n""""""\n\n""""""\nInitializes a new Flask application instance with custom configuration, blueprint registration, and extension setup.\n\nThis function is used to create a new Flask application with custom configuration, blueprint registration, and extension setup. It takes several keyword arguments that define various aspects of the application, such as its import name, static folder path, and template folder path.\n\nThe `__init__` method initializes the Flask application by calling the parent class\'s `__init__` method with some default values. Then it checks if an instance path is provided and sets it to a default value or raises an error if it\'s not absolute.\n\nIt also initializes several attributes, including:\n\n- `instance_path`: The path to the instance folder.\n- `config`: A configuration dictionary that can be used to load a config from files.\n- `aborter`: An aborter object that is called by `flask.abort` to raise HTTP errors.\n- `json`: A JSON provider object that provides access to JSON methods.\n- `url_build_error_handlers`: A list of functions that are called when the application context is destroyed.\n- `teardown_appcontext_funcs`: A list of shell context processor functions that should be run when a shell context is created.\n- `shell_context_processors`: A list of blueprint names mapped to blueprint objects.\n- `blueprints`: A dictionary that maps registered blueprint names to blueprint objects.\n- `extensions`: A dictionary where extensions can store application-specific state.\n- `url_map`: The URL map for this instance.\n\nThe default provider class is the `DefaultJSONProvider` which uses Python\'s built-in JSON library. The default aborter class is the `Aborter` class which raises HTTP errors.\n\n.. versionadded:: 0.7\n""""""\n\n""""""\nInitializes a new Flask application instance with custom configuration, blueprint registration, extension setup, and Click group name.\n\nThis function is used to create a new Flask application with custom configuration, blueprint registration, extension setup, and Click group name. It takes several keyword arguments that define various aspects of the application, such as its import name, static folder path, and template folder path.\n\nThe `__init__` method initializes the Flask application by calling the parent class\'s `__init__` method with some default values. Then it checks if an instance path is provided and sets it to a default value or raises an error if it\'s not absolute.\n\nIt also initializes several attributes, including:\n\n- `instance_path`: The path to the instance folder.\n- `config`: A configuration dictionary that can be used to load a config from files.\n- `aborter`: An aborter object that is called by `flask.abort` to raise HTTP errors.\n- `json`: A JSON provider object that provides access to JSON methods.\n- `url_build_error_handlers`: A list of functions that are called when the application context is destroyed.\n- `teardown_appcontext_funcs`: A list of shell context processor functions that should be run when a shell context is created.\n- `shell_context_processors`: A list of blueprint names mapped to blueprint objects.\n- `blueprints`: A dictionary that maps registered blueprint names to blueprint objects.\n- `extensions`: A dictionary where extensions can store application-specific state.\n- `url_map`: The URL map for this instance.\n\nThe default provider class is the `DefaultJSONProvider` which uses Python\'s built-in JSON library. The default aborter class is the `Aborter` class which raises HTTP errors.\n\n.. versionadded:: 0.7\n""""""\n\n""""""\nInitializes a new Flask application instance with custom configuration, blueprint registration, extension setup, Click group name, and shell context processor functions.\n\nThis function is used to create a new Flask application with custom configuration, blueprint registration, extension setup, Click group name, and shell context processor functions. It takes several keyword arguments that define various aspects of the application, such as its import name, static folder path, and template folder path.\n\nThe `__init__` method initializes the Flask application by calling the parent class\'s `__init__` method with some default values. Then it checks if an instance path is provided and sets it to a default value or raises an error if it\'s not absolute.\n\nIt also initializes several attributes, including:\n\n- `instance_path`: The path to the instance folder.\n- `config`: A configuration dictionary that can be used to load a config from files.\n- `aborter`: An aborter object that is called by `flask.abort` to raise HTTP errors.\n- `json`: A JSON provider object that provides access to JSON methods.\n- `url_build_error_handlers`: A list of functions that are called when the application context is destroyed.\n- `teardown_appcontext_funcs`: A list of shell context processor functions that should be run when a shell context is created.\n- `shell_context_processors`: A list of blueprint names mapped to blueprint objects.\n- `blueprints`: A dictionary that maps registered blueprint names to blueprint objects.\n- `extensions`: A dictionary where extensions can store application-specific state.\n- `url_map`: The URL map for this instance.\n\nThe default provider class is the `DefaultJSONProvider` which uses Python\'s built-in JSON library. The default aborter class is the `Aborter` class which raises HTTP errors.\n\n.. versionadded:: 0.9\n""""""\n\n""""""\nInitializes a new Flask application instance with custom configuration, blueprint registration, extension setup, Click group name, shell context processor functions, and teardown appcontext functions.\n\nThis function is used to create a new Flask application with custom configuration, blueprint registration, extension setup, Click group name, shell context processor functions, and teardown appcontext functions. It takes several keyword arguments that define various aspects of the application, such as its import name, static folder path, and template folder path.\n\nThe `__init__` method initializes the Flask application by calling the parent class\'s `__init__` method with some default values. Then it checks if an instance path is provided and sets it to a default value or raises an error if it\'s not absolute.\n\nIt also initializes several attributes, including:\n\n- `instance_path`: The path to the instance folder.\n- `config`: A configuration dictionary that can be used to load a config from files.\n- `aborter`: An aborter object that is called by `flask.abort` to raise HTTP errors.\n- `json`: A JSON provider object that provides access to JSON methods.\n- `url_build_error_handlers`: A list of functions that are called when the application context is destroyed.\n- `teardown_appcontext_funcs`: A list of shell context processor functions that should be run when a shell context is created.\n- `shell_context_processors`: A list of blueprint names mapped to blueprint objects.\n- `blueprints`: A dictionary that maps registered blueprint names to blueprint objects.\n- `extensions`: A dictionary where extensions can store application-specific state.\n- `url_map`: The URL map for this instance.\n\nThe default provider class is the `DefaultJSONProvider` which uses Python\'s built-in JSON library. The default aborter class is the `Aborter` class which raises HTTP errors.\n\n.. versionadded:: 0.9\n""""""\n\n""""""\nInitializes a new Flask application instance with custom configuration, blueprint registration, extension setup, Click group name, shell context processor functions, teardown appcontext functions, and URL map.\n\nThis function is used to create a new Flask application with custom configuration, blueprint registration, extension setup, Click group name, shell context processor functions, teardown appcontext functions, and URL map. It takes several keyword arguments that define various aspects of the application, such as its import name, static folder path, and template folder path.\n\nThe `__init__` method initializes the Flask application by calling the parent class\'s `__init__` method with some default values. Then it checks if an instance path is provided and sets it to a default value or raises an error if it\'s not absolute.\n\nIt also initializes several attributes, including:\n\n- `instance_path`: The path to the instance folder.\n- `config`: A configuration dictionary that can be used to load a config from files.\n- `aborter`: An aborter object that is called by `flask.abort` to raise HTTP errors.\n- `json`: A JSON provider object that provides access to JSON methods.\n- `url_build_error_handlers`: A list of functions that are called when the application context is destroyed.\n- `teardown_appcontext_funcs`: A list of shell context processor functions that should be run when a shell context is created.\n- `shell_context_processors`: A list of blueprint names mapped to blueprint objects.\n- `blueprints`: A dictionary that maps registered blueprint names to blueprint objects.\n- `extensions`: A dictionary where extensions can store application-specific state.\n- `url_map`: The URL map for this instance.\n\nThe default provider class is the `DefaultJSONProvider` which uses Python\'s built-in JSON library. The default aborter class is the `Aborter` class which raises HTTP errors.\n\n.. versionadded:: 0.9\n""""""\n\n""""""\nInitializes a new Flask application instance with custom configuration, blueprint registration, extension setup, Click group name, shell context processor functions, teardown appcontext functions, URL map, and extensions.\n\nThis function is used to create a new Flask application with custom configuration, blueprint registration, extension setup, Click group name, shell context processor functions, teardown appcontext functions, URL map, and extensions. It takes several keyword arguments that define various aspects of the application, such as its import name, static folder path, and template folder path.\n\nThe `__init__` method initializes the Flask application by calling the parent class\'s `__init__` method with some default values. Then it checks if an instance path is provided and sets it to a default value or raises an error if it\'s not absolute.\n\nIt also initializes several attributes, including:\n\n- `instance_path`: The path to the instance folder.\n- `config`: A configuration dictionary that can be used to load a config from files.\n- `aborter`: An aborter object that is called by `flask.abort` to raise HTTP errors.\n- `json`: A JSON provider object that provides access to JSON methods.\n- `url_build_error_handlers`: A list of functions that are called when the application context is destroyed.\n- `teardown_appcontext_funcs`: A list of shell context processor functions that should be run when a shell context is created.\n- `shell_context_processors`: A list of blueprint names mapped to blueprint objects.\n- `blueprints`: A dictionary that maps registered blueprint names to blueprint objects.\n- `extensions`: A dictionary where extensions can store application-specific state.\n- `url_map`: The URL map for this instance.\n\nThe default provider class is the `DefaultJSONProvider` which uses Python\'s built-in JSON library. The default aborter class is the `Aborter` class which raises HTTP errors.\n\n.. versionadded:: 0.9\n""""""\n\n""""""\nInitializes a new Flask application instance with custom configuration, blueprint registration, extension setup, Click group name, shell context processor functions, teardown appcontext functions, URL map, extensions, and JSON provider.\n\nThis function is used to create a new Flask application with custom configuration, blueprint registration, extension setup, Click group name, shell context processor functions, teardown appcontext functions, URL map, extensions, and JSON provider. It takes several keyword arguments that define various aspects of the application, such as its import name, static folder path, and template folder path.\n\nThe `__init__` method initializes the Flask application by calling the parent class\'s `__init__` method with some default values. Then it checks if an instance path is provided and sets it to a default value or raises an error if it\'s not absolute.\n\nIt also initializes several attributes, including:\n\n- `instance_path`: The path to the instance folder.\n- `config`: A configuration dictionary that can be used to load a config from files.\n- `aborter`: An aborter object that is called by `flask.abort` to raise HTTP errors.\n- `json`: A JSON provider object that provides access to JSON methods.\n- `url_build_error_handlers`: A list of functions that are called when the application context is destroyed.\n- `teardown_appcontext_funcs`: A list of shell context processor functions that should be run when a shell context is created.\n- `shell_context_processors`: A list of blueprint names mapped to blueprint objects.\n- `blueprints`: A dictionary that maps registered blueprint names to blueprint objects.\n- `extensions`: A dictionary where extensions can store application-specific state.\n- `url_map`: The URL map for this instance.\n\nThe default provider class is the `DefaultJSONProvider` which uses Python\'s built-in JSON library. The default aborter class is the `Aborter` class which raises HTTP errors.\n\n.. versionadded:: 0.9\n""""""\n\n""""""\nInitializes a new Flask application instance with custom configuration, blueprint registration, extension setup, Click group name, shell context processor functions, teardown appcontext functions, URL map, extensions, JSON provider, and aborter.\n\nThis function is used to create a new Flask application with custom configuration, blueprint registration, extension setup, Click group name, shell context processor functions, teardown appcontext functions, URL map, extensions, JSON provider, and aborter. It takes several keyword arguments that define various aspects of the application, such as its import name, static folder path, and template folder path.\n\nThe `__init__` method initializes the Flask application by calling the parent class\'s `__init__` method with some default values. Then it checks if an instance path is provided and sets it to a default value or raises an error if it\'s not absolute.\n\nIt also initializes several attributes, including:\n\n- `instance_path`: The path to the instance folder.\n- `config`: A configuration dictionary that can be used to load a config from files.\n- `aborter`: An aborter object that is called by `flask.abort` to raise HTTP errors.\n- `json`: A JSON provider object that provides access to JSON methods.\n- `url_build_error_handlers`: A list of functions that are called when the application context is destroyed.\n- `teardown_appcontext_funcs`: A list of shell context processor functions that should be run when a shell context is created.\n- `shell_context_processors`: A list of blueprint names mapped to blueprint objects.\n- `blueprints`: A dictionary that maps registered blueprint names to blueprint objects.\n- `extensions`: A dictionary where extensions can store application-specific state.\n- `url_map`: The URL map for this instance.\n\nThe default provider class is the `DefaultJSONProvider` which uses Python\'s built-in JSON library. The default aborter class is the `Aborter` class which raises HTTP errors.\n\n.. versionadded:: 0.9\n""""""\n\n""""""\nInitializes a new Flask application instance with custom configuration, blueprint registration, extension setup, Click group name, shell context processor functions, teardown appcontext functions, URL map, extensions, JSON provider, aborter, and Click group name.\n\nThis function is used to create a new Flask application with custom configuration, blueprint registration, extension setup, Click group name, shell context processor functions, teardown appcontext functions, URL map, extensions, JSON provider, aborter, and Click group name. It takes several keyword arguments that define various aspects of the application, such as its import name, static folder path, and template folder path.\n\nThe `__init__` method initializes the Flask application by calling the parent class\'s `__init__` method with some default values. Then it checks if an instance path is provided and sets it to a default value or raises an error if it\'s not absolute.\n\nIt also initializes several attributes, including:\n\n- `instance_path`: The path to the instance folder.\n- `config`: A configuration dictionary that can be used to load a config from files.\n- `aborter`: An aborter object that is called by `flask.abort` to raise HTTP errors.\n- `json`: A JSON provider object that provides access to JSON methods.\n- `url_build_error_handlers`: A list of functions that are called when the application context is destroyed.\n- `teardown_appcontext_funcs`: A list of shell context processor functions that should be run when a shell context is created.\n- `shell_context_processors`: A list of blueprint names mapped to blueprint objects.\n- `blueprints`: A dictionary that maps registered blueprint names to blueprint objects.\n- `extensions`: A dictionary where extensions can store application-specific state.\n- `url_map`: The URL map for this instance.\n\nThe default provider class is the `DefaultJSONProvider` which uses Python\'s built-in JSON library. The default aborter class is the `Aborter` class which raises HTTP errors.\n\n.. versionadded:: 0.9\n""""""\n\n""""""\nInitializes a new Flask application instance with custom configuration, blueprint registration, extension setup, Click group name, shell context processor functions, teardown appcontext functions, URL map, extensions, JSON provider, aborter, Click group name, and template folder path.\n\nThis function is used to create a new Flask application with custom configuration, blueprint registration, extension setup, Click group name, shell context processor functions, teardown appcontext functions, URL map, extensions, JSON provider, aborter, Click group name, and template folder path. It takes several keyword arguments that define various aspects of the application, such as its import name, static folder path, and template folder path.\n\nThe `__init__` method initializes the Flask application by calling the parent class\'s `__init__` method with some default values. Then it checks if an instance path is provided and sets it to a default value or raises an error if it\'s not absolute.\n\nIt also initializes several attributes, including:\n\n- `instance_path`: The path to the instance folder.\n- `config`: A configuration dictionary that can be used to load a config from files.\n- `aborter`: An aborter object that is called by `flask.abort` to raise HTTP errors.\n- `json`: A JSON provider object that provides access to JSON methods.\n- `url_build_error_handlers`: A list of functions that are called when the application context is destroyed.\n- `teardown_appcontext_funcs`: A list of shell context processor functions that should be run when a shell context is created.\n- `shell_context_processors`: A list of blueprint names mapped to blueprint objects.\n- `blueprints`: A dictionary that maps registered blueprint names to blueprint objects.\n- `extensions`: A dictionary where extensions can store application-specific state.\n- `url_map`: The URL map for this instance.\n\nThe default provider class is the `DefaultJSONProvider` which uses Python\'s built-in JSON library. The default aborter class is the `Aborter` class which raises HTTP errors.\n\n.. versionadded:: 0.9\n""""""\n\n""""""\nInitializes a new Flask application instance with custom configuration, blueprint registration, extension setup, Click group name, shell context processor functions, teardown appcontext functions, URL map, extensions, JSON provider, aborter, Click group name, template folder path, and static folder path.\n\nThis function is used to create a new Flask application with custom configuration, blueprint registration, extension setup, Click group name, shell context processor functions, teardown appcontext functions, URL map, extensions, JSON provider, aborter, Click group name, template folder path, and static folder path. It takes several keyword arguments that define various aspects of the application, such as its import name, static folder path, and template folder path.\n\nThe `__init__` method initializes the Flask application by calling the parent class\'s `__init__` method with some default values. Then it checks if an instance path is provided and sets it to a default value or raises an error if it\'s not absolute.\n\nIt also initializes several attributes, including:\n\n- `instance_path`: The path to the instance folder.\n- `config`: A configuration dictionary that can be used to load a config from files.\n- `aborter`: An aborter object that is called by `flask.abort` to raise HTTP errors.\n- `json`: A JSON provider object that provides access to JSON methods.\n- `url_build_error_handlers`: A list of functions that are called when the application context is destroyed.\n- `teardown_appcontext_funcs`: A list of shell context processor functions that should be run when a shell context is created.\n- `shell_context_processors`: A list of blueprint names mapped to blueprint objects.\n- `blueprints`: A dictionary that maps registered blueprint names to blueprint objects.\n- `extensions`: A dictionary where extensions can store application-specific state.\n- `url_map`: The URL map for this instance.\n\nThe default provider class is the `DefaultJSONProvider` which uses Python\'s built-in JSON library. The default aborter class is the `Aborter` class which raises HTTP errors.\n\n.. versionadded:: 0.9\n""""""\n\n""""""\nInitializes a new Flask application instance with custom configuration, blueprint registration, extension setup, Click group name, shell context processor functions, teardown appcontext functions, URL map, extensions, JSON provider, aborter, Click group name, template folder path, static folder path, and import name.\n\nThis function is used to create a new Flask application with custom configuration, blueprint registration, extension setup, Click group name, shell context processor functions, teardown appcontext functions, URL map, extensions, JSON provider, aborter, Click group name, template folder path, static folder path, and import name. It takes several keyword arguments that define various aspects of the application, such as its import name, static folder path, and template folder path.\n\nThe `__init__` method initializes the Flask application by calling the parent class\'s `__init__` method with some default values. Then it checks if an instance path is provided and sets it to a default value or raises an error if it\'s not absolute.\n\nIt also initializes several attributes, including:\n\n- `instance_path`: The path to the instance folder.\n- `config`: A configuration dictionary that can be used to load a config from files.\n- `aborter`: An aborter object that is called by `flask.abort` to raise HTTP errors.\n- `json`: A JSON provider object that provides access to JSON methods.\n- `url_build_error_handlers`: A list of functions that are called when the application context is destroyed.\n- `teardown_appcontext_funcs`: A list of shell context processor functions that should be run when a shell context is created.\n- `shell_context_processors`: A list of blueprint names mapped to blueprint objects.\n- `blueprints`: A dictionary that maps registered blueprint names to blueprint objects.\n- `extensions`: A dictionary where extensions can store application-specific state.\n- `url_map`: The URL map for this instance.\n\nThe default provider class is the `DefaultJSONProvider` which uses Python\'s built-in JSON library. The default aborter class is the `Aborter` class which raises HTTP errors.\n\n.. versionadded:: 0.9\n""""""\n\n""""""\nInitializes a new Flask application instance with custom configuration, blueprint registration, extension setup, Click group name, shell context processor functions, teardown appcontext functions, URL map, extensions, JSON provider, aborter, Click group name, template folder path, static folder path, import name, and config.\n\nThis function is used to create a new Flask application with custom configuration, blueprint registration, extension setup, Click group name, shell context processor functions, teardown appcontext functions, URL map, extensions, JSON provider, aborter, Click group name, template folder path, static folder path, import name, and config. It takes several keyword arguments that define various aspects of the application, such as its import name, static folder path, and template folder path.\n\nThe `__init__` method initializes the Flask application by calling the parent class\'s `__init__` method with some default values. Then it checks if an instance path is provided and sets it to a default value or raises an error if it\'s not absolute.\n\nIt also initializes several attributes, including:\n\n- `instance_path`: The path to the instance folder.\n- `config`: A configuration dictionary that can be used to load a config from files.\n- `aborter`: An aborter object that is called by `flask.abort` to raise HTTP errors.\n- `json`: A JSON provider object that provides access to JSON methods.\n- `url_build_error_handlers`: A list of functions that are called when the application context is destroyed.\n- `teardown_appcontext_funcs`: A list of shell context processor functions that should be run when a shell context is created.\n- `shell_context_processors`: A list of blueprint names mapped to blueprint objects.\n- `blueprints`: A dictionary that maps registered blueprint names to blueprint objects.\n- `extensions`: A dictionary where extensions can store application-specific state.\n- `url_map`: The URL map for this instance.\n\nThe default provider class is the `DefaultJSONProvider` which uses Python\'s built-in JSON library. The default aborter class is the `Aborter` class which raises HTTP errors.\n\n.. versionadded:: 0.9\n""""""\n\n""""""\nInitializes a new Flask application instance with custom configuration, blueprint registration, extension setup, Click group name, shell context processor functions, teardown appcontext functions, URL map, extensions, JSON provider, aborter, Click group name, template folder path, static folder path, import name, config, and config_overrides.\n\nThis function is used to create a new Flask application with custom configuration, blueprint registration, extension setup, Click group name, shell context processor functions, teardown appcontext functions, URL map, extensions, JSON provider, aborter, Click group name, template folder path, static folder path, import name, config, and config_overrides. It takes several keyword arguments that define various aspects of the application, such as its import name, static folder path, and template folder path.\n\nThe `__init__` method initializes the Flask application by calling the parent class\'s `__init__` method with some default values. Then it checks if an instance path is provided and sets it to a default value or raises an error if it\'t')","(True, '""""""\nReturns the name of the current module or \'main\' if running directly.\n\nIf running directly, attempts to retrieve the filename from sys.modules[\'__main__\'].\nIf not found, returns \'__main__\'. Otherwise, returns the base filename without extension.\n\nArgs:\n    None\n\nReturns:\n    str: The name of the current module or \'main\'.\n""""""')","(True, '""""""\nReturns whether the debug mode is enabled based on the configuration.\n\nArgs:\n    None\n\nReturns:\n    bool: True if debug mode is enabled, False otherwise\n""""""')","(False, 'def add_url_rule(\n    rule: str,\n    endpoint: str | None = None,\n    view_func: ft.RouteCallable | None = None,\n    provide_automatic_options: bool | None = None,\n    **options: t.Any,\n) -> None:\n    """"""\n    Adds a URL rule to the application\'s URL map.\n\n    This function is used to register routes for an application. It takes\n    several parameters, including the route rule, endpoint, view function,\n    and options. The endpoint and view function are optional and can be\n    specified if they are already defined elsewhere in the code.\n\n    Args:\n        rule (str): The URL rule to add.\n        endpoint (str | None): The endpoint for this rule. Defaults to None.\n        view_func (ft.RouteCallable | None): The view function for this rule. Defaults to None.\n        provide_automatic_options (bool | None): Whether to automatically\n            include OPTIONS in the route. Defaults to None.\n        **options: t.Any: Additional options for the route.\n\n    Returns:\n        None\n\n    Raises:\n        TypeError: If the methods are not a list of strings.\n        AssertionError: If the view function mapping is overwriting an existing endpoint function.\n    """"""')","(True, '""""""\nInjects URL defaults into the provided endpoint.\n\nThis function is used to inject default values from a dictionary into an endpoint.\nIt can be called outside of a request context and will parse the passed endpoint\nto determine which blueprint it belongs to. It then calls the specified functions\nfor each name in the parsed path, passing the endpoint and values as arguments.\n\nArgs:\n    endpoint (str): The URL endpoint to inject defaults into.\n    values (dict[str, t.Any]): A dictionary of default values to inject.\n\nReturns:\n    None\n\nRaises:\n    ValueError: If the endpoint is not a valid URL.\n""""""')","(True, '""""""\nAdds a URL rule to the application.\n\nParameters:\n    rule (str): The URL pattern.\n    endpoint (str | None, optional): The endpoint name. Defaults to None.\n    view_func (ft.RouteCallable | None, optional): The view function. Defaults to None.\n    **options (t.Any): Additional options for the URL rule.\n\nReturns:\n    None\n""""""')","(True, '""""""\nInitialize a new instance of the class.\n\nParameters:\n    name (str): The name of the application or module.\n    import_name (str): The import name of the application or module.\n    static_folder (str | os.PathLike[str] | None, optional): The path to the static folder. Defaults to None.\n    static_url_path (str | None, optional): The URL path for static files. Defaults to None.\n    template_folder (str | os.PathLike[str] | None, optional): The path to the template folder. Defaults to None.\n    url_prefix (str | None, optional): The prefix for URLs. Defaults to None.\n    subdomain (str | None, optional): The subdomain for URLs. Defaults to None.\n    url_defaults (dict[str, t.Any] | None, optional): Default values for URL parameters. Defaults to None.\n    root_path (str | None, optional): The path of the application or module. Defaults to None.\n    cli_group (str | None, optional): The CLI group name. Defaults to _sentinel.\n\nRaises:\n    ValueError: If \'name\' is empty or contains a dot \'.\' character.\n\nAttributes:\n    name (str): The name of the application or module.\n    url_prefix (str): The prefix for URLs.\n    subdomain (str): The subdomain for URLs.\n    deferred_functions (list[DeferredSetupFunction]): A list of deferred functions.\n    url_values_defaults (dict[str, t.Any]): Default values for URL parameters.\n    cli_group (str): The CLI group name.\n    _blueprints (list[tuple[Blueprint, dict[str, t.Any]]]): A list of blueprints and their configurations.\n\n""""""')","(False, '""""""\nRecords a deferred setup function.\n\nArgs:\n    func (DeferredSetupFunction): The deferred setup function to be recorded.\n\nReturns:\n    None\n""""""\ndef record(self, func: DeferredSetupFunction) -> None:\n    """"""\n    Records a deferred setup function.\n\n    Args:\n        func (DeferredSetupFunction): The deferred setup function to be recorded.\n    """"""\n    self.deferred_functions.append(func)')","(True, '""""""\nRecords a function to be executed once during the setup process.\n\nThis method is used to register a function that should only be executed once,\nduring the initial setup of the application. The function is wrapped in a\ndecorator to ensure it\'s only called once, even if the blueprint is reloaded.\n\nArgs:\n    func (DeferredSetupFunction): The function to be recorded and executed.\n    \nReturns:\n    None\n""""""')","(False, 'def make_setup_state(app: App, options: dict[str, t.Any], first_registration: bool = False) -> BlueprintSetupState:\n    """"""\n    Creates a new setup state for the given application.\n\n    Args:\n    - app (App): The application instance.\n    - options (dict[str, t.Any]): A dictionary of options to be used in the setup state.\n    - first_registration (bool, optional): Whether this is the first registration. Defaults to False.\n\n    Returns:\n    - BlueprintSetupState: The newly created setup state.\n    """"""')","(False, ""```\n## register\n\nRegisters the current object as a blueprint in the provided application.\n\n### Parameters:\n\n- `app`: The Flask application instance to register with.\n- `options`: A dictionary of options for the registration process. Can include:\n  - `name_prefix`: An optional prefix for the blueprint name (default: empty string).\n  - `name`: An optional override for the blueprint name, which takes precedence over `name_prefix` (default: current object's name).\n\n### Returns:\n\nNone\n\n### Raises:\n\n- `ValueError`: If a blueprint with the same name already exists in the application.\n\n### Notes:\n\nThis method registers the current object as a blueprint in the provided Flask application. It checks for existing blueprints with the same name and raises an error if one is found. The registration process also updates the application's state and adds any necessary URL rules or commands to the CLI."")","(True, '""""""\nMerges blueprint functions into the application\'s configuration.\n\nThis function merges the provided blueprint functions (`bp_dict`) into the\napplication\'s configuration. It updates the `error_handler_spec`, `view_functions`,\n`before_request_funcs`, `after_request_funcs`, `teardown_request_funcs`, `url_default_functions`,\n`url_value_preprocessors`, and `template_context_processors` dictionaries with the merged values.\n\nArgs:\n    app (App): The application instance.\n    name (str): The blueprint name to merge functions under.\n\nReturns:\n    None\n""""""')","(True, '""""""\nExtends the `parent_dict` with the items from `bp_dict`, \noverwriting any existing keys.\n\nArgs:\n    - **bp_dict**: A dictionary mapping blueprint or app keys to lists of values.\n    - **parent_dict**: The dictionary to extend, also mapping blueprint or app keys to lists of values.\n\nReturns:\n    None\n""""""')","(False, '""""""\nApplies an error handler to a blueprint.\n\nThis function returns a decorator that can be used to apply an error handler to a blueprint.\nThe error handler is specified by the `code` parameter, which can be either an exception type or an integer code.\n\nArgs:\n    self: The instance of the class this method belongs to.\n    code (type[Exception] | int): The code for the error handler. Can be either an exception type or an integer code.\n\nReturns:\n    T_error_handler: A decorator that applies the specified error handler to a blueprint.\n\nYields:\n    None\n""""""\ndef app_errorhandler(\n        self, code: type[Exception] | int\n    ) -> t.Callable[[T_error_handler], T_error_handler]:\n\n        def decorator(f: T_error_handler) -> T_error_handler:\n            def from_blueprint(state: BlueprintSetupState) -> None:\n                state.app.errorhandler(code)(f)\n\n            self.record_once(from_blueprint)\n            return f\n\n        return decorator')","(True, '""""""\nDecorates an error handler function with the ability to be registered once in a Blueprint\'s setup.\n\nArgs:\n    f (T_error_handler): The error handler function to decorate.\n\nReturns:\n    T_error_handler: The decorated error handler function.\n""""""')","(True, '""""""\nHandles error handling for an application using a blueprint setup state.\n\nArgs:\n    state (BlueprintSetupState): The current state of the blueprint setup.\nReturns:\n    None\nRaises:\n    Exception: If an error occurs during error handling.\n""""""')","(True, '""""""\nDecorates a method with setup functionality.\n\nThis function takes a method `f` as input and returns a wrapper function that checks if the setup process is finished before calling the original method. The wrapper function also updates the `__name__` attribute of the original method to include the name of the decorated method.\n\nArgs:\n    f (F): The method to be decorated.\n\nReturns:\n    F: The decorated method.\n""""""')","(True, '""""""\nWrapper function for a scaffold object.\n\nThis function acts as a proxy to the underlying `f` method of the scaffold object.\nIt checks if the setup is finished before calling the original method and returns\nthe result.\n\nArgs:\n    self (Scaffold): The scaffold object instance.\n    *args: Variable number of positional arguments passed to the original method.\n    **kwargs: Variable number of keyword arguments passed to the original method.\n\nReturns:\n    Any: The result of the original method call.\n\nRaises:\n    None\n\nNote:\nThis function is a wrapper and does not modify the behavior of the underlying `f` method.\nIt is intended to provide additional functionality or error checking before calling the original method.\n""""""')","(True, '""""""\nInitialize a Flask application.\n\nThis function initializes a new instance of the Flask class. It takes several\nparameters that define the configuration and behavior of the application.\n\nParameters:\n    import_name (str): The name of the package or module that this object belongs to.\n    static_folder (str | os.PathLike[str] | None, optional): The path to the static folder.\n    static_url_path (str | None, optional): The URL path for static files.\n    template_folder (str | os.PathLike[str] | None, optional): The path to the templates folder.\n    root_path (str | None, optional): The absolute path to the package on the filesystem.\n\nAttributes:\n    import_name (str): The name of the package or module that this object belongs to.\n    static_folder (str | os.PathLike[str] | None): The path to the static folder.\n    static_url_path (str | None): The URL path for static files.\n    template_folder (str | os.PathLike[str] | None): The path to the templates folder.\n    root_path (str | None): The absolute path to the package on the filesystem.\n    cli (click.Group): The Click command group for registering CLI commands.\n    view_functions (dict[str, ft.RouteCallable]): A dictionary mapping endpoint names to view functions.\n    error_handler_spec (dict[ft.AppOrBlueprintKey, dict[int | None, dict[type[Exception], ft.ErrorHandlerCallable]]]): A data structure of registered error handlers.\n    before_request_funcs (dict[ft.AppOrBlueprintKey, list[ft.BeforeRequestCallable]]): A data structure of functions to call at the beginning of each request.\n    after_request_funcs (dict[ft.AppOrBlueprintKey, list[ft.AfterRequestCallable[t.Any]]]): A data structure of functions to call at the end of each request.\n    teardown_request_funcs (dict[ft.AppOrBlueprintKey, list[ft.TeardownCallable]]): A data structure of functions to call at the end of each request even if an exception is raised.\n    template_context_processors (dict[ft.AppOrBlueprintKey, list[ft.TemplateContextProcessorCallable]]): A data structure of functions to call to pass extra context values when rendering templates.\n    url_value_preprocessors (dict[ft.AppOrBlueprintKey, list[ft.URLValuePreprocessorCallable]]): A data structure of functions to call to modify the keyword arguments passed to the view function.\n    url_default_functions (dict[ft.AppOrBlueprintKey, list[ft.URLDefaultCallable]]): A data structure of functions to call to modify the keyword arguments when generating URLs.\n\nRaises:\n    TypeError: If any parameter is not of the correct type.\n""""""')","(True, '""""""\nSets the static folder path.\n\nThis method sets the path to the static folder. If a path is provided, it will be normalized and stripped of trailing slashes.\n\nArgs:\n    value (str | os.PathLike[str] | None): The path to the static folder. Can be an absolute or relative path, or `None` for no static folder.\n\nReturns:\n    None\n""""""')","(True, '""""""\nReturns a method route for the given rule and options.\n\nThis function is used to create a method-specific route for a given rule.\nIt takes in the method name, rule string, and options dictionary as parameters.\nThe returned callable can be used to decorate a class or function with the specified method.\n\nArgs:\n    self: The instance of the class that contains this method.\n    method (str): The name of the method to route.\n    rule (str): The rule for which the method will be applied.\n    options (dict[str, t.Any]): Additional keyword arguments to pass to the `route` method.\n\nReturns:\n    t.Callable[[T_route], T_route]: A callable that can be used to decorate a class or function with the specified method.\n\nRaises:\n    TypeError: If the \'methods\' argument is provided in the options dictionary.\n""""""')","(False, 'def _endpoint_from_view_func(view_func: ft.RouteCallable) -> str:\n    """"""\n    Extracts the endpoint name from a view function.\n\n    Args:\n        view_func (ft.RouteCallable): The view function to extract the endpoint from.\n    \n    Returns:\n        str: The endpoint name of the provided view function.\n\n    Raises:\n        AssertionError: If the view function is None, indicating that an endpoint was not provided.\n    """"""')","(False, '""""""\nFind the path to a Python package or module.\n\nThis function takes an import name as input and returns the path to the corresponding package or module.\nIf the package or module is not found, it raises a ValueError. If the import fails due to invalid module name,\nit falls back to the current working directory.\n\nArgs:\n    import_name (str): The name of the package or module to find.\n\nReturns:\n    str: The path to the package or module.\n\nRaises:\n    ValueError: If the package or module is not found.\n""""""\n\ndef _find_package_path(import_name: str) -> str:')","(False, 'def find_package(import_name: str) -> tuple[str | None, str]:\n    """"""\n    Finds the path to a Python package.\n\n    Args:\n    import_name (str): The name of the package to find.\n\n    Returns:\n    A tuple containing the prefix and path to the package. If the package is not installed,\n    returns (None, package_path).\n\n    Note:\n    This function uses internal implementation details and should not be used directly.\n    It\'s intended for use by other parts of the Python interpreter or tools that need to\n    find packages.\n\n    Raises:\n    None\n\n    Examples:\n    >>> find_package(""numpy"")\n    (\'/usr/lib/python3.9/site-packages\', \'/usr/lib/python3.9/site-packages/numpy\')\n    """"""\n\n    package_path = _find_package_path(import_name)\n    py_prefix = os.path.abspath(sys.prefix)\n\n    # installed to the system\n    if _path_is_relative_to(pathlib.PurePath(package_path), py_prefix):\n        return py_prefix, package_path\n\n    site_parent, site_folder = os.path.split(package_path)\n\n    # installed to a virtualenv\n    if site_folder.lower() == ""site-packages"":\n        parent, folder = os.path.split(site_parent)\n\n        # Windows (prefix/lib/site-packages)\n        if folder.lower() == ""lib"":\n            return parent, package_path\n\n        # Unix (prefix/lib/pythonX.Y/site-packages)\n        if os.path.basename(parent).lower() == ""lib"":\n            return os.path.dirname(parent), package_path\n\n        # something else (prefix/site-packages)\n        return site_parent, package_path\n\n    # not installed\n    return None, package_path')","(False, '""""""\n    Initializes the object with an optional initial value.\n\n    Args:\n        initial (t.Any): The initial value of the object. Defaults to None.\n\n    Returns:\n        None\n""""""\n\n""""""\n    Updates the object\'s state by marking it as modified and accessed.\n\n    This method is called automatically when the object is updated.\n""""""')","(True, '""""""\nUpdates the object\'s state after a modification.\n\nThis method is called when an update operation is performed on the object.\nIt sets `self.modified` and `self.accessed` to indicate that the object has been modified and accessed, respectively.\n\nArgs:\n    None\n\nReturns:\n    None\n""""""')","(True, '""""""\nReturns the name of the cookie used by the given Flask application for session management.\n\nArgs:\n    app (Flask): The Flask application instance.\n\nReturns:\n    str: The name of the session cookie.\n""""""')","(True, '""""""\nReturns the domain of the session cookie.\n\nThis method retrieves the value of the `SESSION_COOKIE_DOMAIN` configuration\nvariable from the provided Flask application instance. If no such variable is set,\nthe function returns `None`.\n\nArgs:\n    app (Flask): The Flask application instance to retrieve the cookie domain from.\n\nReturns:\n    str | None: The domain of the session cookie, or `None` if not set.\n""""""')","(True, '""""""\nReturns the path of the cookie for a given Flask application.\n\nThe function checks if `SESSION_COOKIE_PATH` is set in the application\'s configuration.\nIf it is, that value is returned. Otherwise, it falls back to using `APPLICATION_ROOT`.\n\nArgs:\n    app (Flask): The Flask application instance.\n\nReturns:\n    str: The path of the cookie for the given application.\n""""""')","(True, '""""""\nReturns whether the session cookie is set to be HTTP-only.\n\nArgs:\n    app (Flask): The application instance.\n\nReturns:\n    bool: True if the session cookie is HTTP-only, False otherwise.\n""""""')","(True, '""""""\nReturns whether the session cookie is secure.\n\nThis method checks if the `SESSION_COOKIE_SECURE` configuration variable\nis set to True in the provided Flask application. If it is, the function\nreturns True; otherwise, it returns False.\n\nArgs:\n    app (Flask): The Flask application instance to check.\n\nReturns:\n    bool: Whether the session cookie is secure.\n""""""')","(True, '""""""\nReturns the value of the \'SESSION_COOKIE_SAMESITE\' configuration option from the provided Flask application.\n\nArgs:\n    app (Flask): The Flask application instance to retrieve the configuration from.\n\nReturns:\n    str | None: The value of the \'SESSION_COOKIE_SAMESITE\' configuration option, or None if it is not set.\n""""""')","(True, '""""""\nReturns the source code for a given template in an environment.\n\nArgs:\n    - `environment`: The BaseEnvironment instance to retrieve the source from.\n    - `template`: The name of the template to get the source for.\n\nReturns:\n    A tuple containing:\n        1. The source code as a string.\n        2. An optional error message as a string, or None if no error occurred.\n        3. An optional callable function that can be used to check if the source is valid, or None if not needed.\n\nIf `EXPLAIN_TEMPLATE_LOADING` is enabled in the application configuration, this function will return an explained source code. Otherwise, it will use a faster method to retrieve the source code.\n""""""')","(True, '""""""\nReturns the source explanation for a given template in the specified environment.\n\nThis function iterates over all loaders for the provided template and attempts to retrieve the source explanation.\nIf successful, it returns a tuple containing the source code, error message (if any), and a callable that can be used to check if the source is valid.\nIf no loader is able to retrieve the source, it raises a TemplateNotFound exception.\n\nArgs:\n    environment (BaseEnvironment): The environment in which to retrieve the source explanation.\n    template (str): The template for which to retrieve the source explanation.\n\nReturns:\n    tuple[str, str | None, t.Callable[[], bool] | None]: A tuple containing the source code, error message (if any), and a callable that can be used to check if the source is valid.\nRaises:\n    TemplateNotFound: If no loader is able to retrieve the source explanation for the provided template.\n\nNote:\n    This function uses a debug helper to log the loading attempts for the given template.\n""""""')","(True, '""""""\nReturns the source code of a given template in the specified environment.\n\nArgs:\n    - `environment`: The base environment to use for loading templates.\n    - `template`: The name of the template to retrieve the source code for.\n\nReturns:\n    A tuple containing the source code as a string, and an optional loader function that can be used to load the template. If no loader is found, returns None.\n\nRaises:\n    TemplateNotFound: If the specified template cannot be found.\n""""""')","(True, '""""""\nYields tuples of scaffold and base loader instances.\n\nThis function iterates over the available loaders in the application\'s Jinja template engine,\nyielding a tuple containing each scaffold and its corresponding base loader. If no loaders are found,\nit returns an empty iterator.\n\nArgs:\n    template (str): The current template being processed.\n\nReturns:\n    t.Iterator[tuple[Scaffold, BaseLoader]]: An iterator yielding tuples of scaffold and base loader instances.\n""""""')","(True, '""""""\nYield a session object for the current test request context.\n\nThis function is used to create and manage sessions for testing purposes.\nIt checks if cookies are enabled, sets them up, opens a new session,\nand saves it after use. If the session backend fails to open a session,\nit raises a RuntimeError.\n\nArgs:\n    *args: Variable arguments passed to the test request context.\n    **kwargs: Keyword arguments passed to the test request context.\n\nReturns:\n    An iterator yielding SessionMixin objects for each session opened.\n""""""')","(True, '""""""\nCopies the environment of another WSGIEnvironment instance.\n\nThis method creates a new dictionary containing all key-value pairs from both `self` and `other`. If `preserve_context` is True, it also adds the `_new_contexts` attribute to the resulting dictionary.\n\nArgs:\n    other (WSGIEnvironment): The environment to copy from.\n\nReturns:\n    WSGIEnvironment: A new WSGIEnvironment instance with the copied environment.\n""""""')","(True, '""""""\nReturns a BaseRequest object created from the provided arguments and keyword arguments.\n\nArgs:\n    - args (tuple[t.Any, ...]): A tuple of positional arguments.\n    - kwargs (dict[str, t.Any]): A dictionary of keyword arguments.\n\nReturns:\n    BaseRequest: The created BaseRequest object.\n\nRaises:\n    None\n\nNote:\n    This function creates an EnvironBuilder instance and uses it to get a request. It ensures the builder is properly closed after use.\n""""""')","(True, '""""""\nOpens a new test session.\n\nThis method is used to create a new test environment. It takes in various arguments and keyword arguments that can be used to customize the behavior of the test session.\n\nArgs:\n    *args: A variable number of positional arguments. If provided, they are used to initialize the request object.\n    buffered (bool): Whether to buffer the response. Defaults to False.\n    follow_redirects (bool): Whether to follow redirects. Defaults to False.\n    **kwargs: A dictionary of keyword arguments.\n\nReturns:\n    TestResponse: The test response object.\n\nRaises:\n    ValueError: If the provided arguments are invalid.\n""""""')","(True, '""""""\nInvokes the parent class\'s invoke method with optional CLI and arguments.\n\nThis function is used to initialize the script info object and pass it to the parent class\'s invoke method.\nIf no \'obj\' key is provided in kwargs, a ScriptInfo object is created with a create_app lambda that returns the app instance.\n\nArgs:\n    cli (t.Any): The command line interface. Defaults to self.app.cli if None.\n    args (t.Any): Any additional arguments. Defaults to None.\n    **kwargs (t.Any): Additional keyword arguments. Must include \'obj\' key.\n\nReturns:\n    t.Any: The result of the parent class\'s invoke method.\n""""""')","(False, '""""""\nConverts a class-based view to a function-based view.\n\nThis function takes a class, name, and optional arguments and keyword arguments,\nand returns a function that can be used as a view in the application.\n\nIf `cls.init_every_request` is True, the returned function will initialize\nthe class instance before each request. Otherwise, it will simply create an\ninstance of the class.\n\nThe returned function also has its name, module, and docstring set to those\nof the original class, and any decorators from the class are applied to the\nfunction.\n\nThis allows for easy testing and debugging by replacing the view with a\ndifferent class or function.\n""""""\ndef as_view(\n    cls: type,\n    name: str,\n    *class_args: Any,\n    **class_kwargs: Any\n) -> RouteCallable:\n    ...\n')","(True, '""""""\nView a request.\n\nThis function is used to handle HTTP requests. It takes in any number of keyword arguments,\nwhich are then passed to the `dispatch_request` method of the view class instance.\nThe result of this method call is returned as an HTTP response.\n\nArgs:\n    **kwargs: Any additional keyword arguments to be passed to the view class.\n\nReturns:\n    ft.ResponseReturnValue: The result of the `dispatch_request` method call.\n\nRaises:\n    None\n""""""')","(True, '""""""\nView a request.\n\nDispatches the given request to the appropriate handler and returns the response.\n\nArgs:\n    **kwargs (t.Any): Keyword arguments to be passed to the dispatch_request method.\n\nReturns:\n    ft.ResponseReturnValue: The response returned by the dispatched request.\n""""""')","(False, 'def dispatch_request(self, **kwargs: t.Any) -> ft.ResponseReturnValue:\n    """"""\n    Dispatches a request to the appropriate handler.\n\n    If the request method is HEAD and no handler is found for it,\n    this function will retry with GET. It asserts that a handler\n    exists for the requested method, raising an error if not.\n    \n    Args:\n        **kwargs: Keyword arguments to be passed to the handler.\n        \n    Returns:\n        The response returned by the handler.\n    """"""\n    meth = getattr(self, request.method.lower(), None)\n\n    # If the request method is HEAD and we don\'t have a handler for it\n    # retry with GET.\n    if meth is None and request.method == ""HEAD"":\n        meth = getattr(self, ""get"", None)\n\n    assert meth is not None, f""Unimplemented method {request.method!r}""\n    return current_app.ensure_sync(meth)(**kwargs)  # type: ignore[no-any-return]')","(True, '""""""\nReturns the maximum allowed content length for the application.\n\nIf `current_app` is available, it returns the value from `current_app.config[""MAX_CONTENT_LENGTH""]`.\nOtherwise, it returns `None`.\n\nArgs:\n    None\n\nReturns:\n    int | None: The maximum allowed content length or None if not configured.\n""""""')","(False, '""""""\nReturns the maximum cookie size.\n\nIf running within an application context, returns the value from `current_app.config[""MAX_COOKIE_SIZE""]`.\nOtherwise, falls back to Werkzeug\'s default.')"
"(True, '""""""\nDecorates a function to run with the application context.\n\nThis decorator is used to ensure that functions decorated with it are executed within\nthe application\'s context. This can be useful for tasks such as database operations,\nfile I/O, or any other operation that requires access to the current application state.\n\nThe `with_appcontext` function takes a function `f` as an argument and returns the result of\ninvoking `f` with the application context. If the application context is not already set,\nit will load the application from the `ScriptInfo` object associated with the click context.\n\nArgs:\n    f (function): The function to be decorated.\n\nReturns:\n    function: The original function, wrapped in a decorator that runs it with the application context.\n""""""')","(False, '""""""\nReturns a decorator that appends the provided callable to the list of functions \nto be executed after the current request has been completed.\n\nArgs:\n    f (ft.AfterRequestCallable[t.Any]): The callable to be appended to the list.\n\nReturns:\n    ft.AfterRequestCallable[t.Any]: The decorated function.\nRaises:\n    RuntimeError: If no request context is active, indicating that \'after_this_request\' \n                  can only be used when a request context is active, such as in a view function.')","(False, 'def stream_with_context(\n    generator_or_function: t.Iterator[t.AnyStr] | t.Callable[..., t.Iterator[t.AnyStr]],\n) -> t.Iterator[t.AnyStr]:\n    """"""\n    Stream a generator or function with context.\n\n    This function takes an iterator or callable that returns an iterator, and wraps it in a context manager.\n    The context manager pushes the current request context onto the stack when the generator is started,\n    and pops it off when the iteration completes.\n\n    If the input is not an iterator, but rather a callable that returns an iterator,\n    this function will wrap the callable in a decorator to create a new function that takes any arguments\n    and returns an iterator. This allows the original function to be used as if it were an iterator.\n\n    The context manager uses the `_cv_request` object to get the current request context, and pushes it onto the stack when the generator is started.\n    When the iteration completes, the context is popped off the stack.\n\n    This function can only be used when a request context is active, such as in a view function.\n\n    Args:\n        generator_or_function: An iterator or callable that returns an iterator.\n\n    Returns:\n        An iterator over the results of the input generator or function.\n""""""\n    try:\n        gen = iter(generator_or_function)  # type: ignore[arg-type]\n    except TypeError:\n\n        def decorator(*args: t.Any, **kwargs: t.Any) -> t.Any:\n            """"""\n            Decorates a function or generator with the `stream_with_context` function from the `itertools` module.\n\n            Args:\n                *args (t.Any): Variable number of positional arguments to be passed to the decorated function or generator.\n                **kwargs (t.Any): Variable number of keyword arguments to be passed to the decorated function or generator.\n\n            Returns:\n                t.Any: The result of applying the `stream_with_context` function to the provided function or generator.\n\n            Note:\n                This decorator is used to convert a function or generator into an iterator that can be used with the `stream_with_context` function.\n            """"""\n            gen = generator_or_function(*args, **kwargs)  # type: ignore[operator]\n            return stream_with_context(gen)\n\n        return update_wrapper(decorator, generator_or_function)  # type: ignore[arg-type]\n\n    def generator() -> t.Iterator[t.AnyStr | None]:\n        ctx = _cv_request.get(None)\n        if ctx is None:\n            raise RuntimeError(\n                ""\'stream_with_context\' can only be used when a request""\n                "" context is active, such as in a view function.""\n            )\n        with ctx:\n            # Dummy sentinel.  Has to be inside the context block or we\'re\n            # not actually keeping the context around.\n            yield None\n\n            # The try/finally is here so that if someone passes a WSGI level\n            # iterator in we\'re still running the cleanup logic.  Generators\n            # don\'t need that because they are closed on their destruction\n            # automatically.\n            try:\n                yield from gen\n            finally:\n                if hasattr(gen, ""close""):\n                    gen.close()\n\n    # The trick is to start the generator.  Then the code execution runs until\n    # the first dummy None is yielded at which point the context was already\n    # pushed.  This item is discarded.  Then when the iteration continues the\n    # real generator is executed.\n    wrapped_g = generator()\n    next(wrapped_g)\n    return wrapped_g  # type: ignore[return-value]')","(False, 'def jsonify(*args: t.Any, **kwargs: t.Any) -> Response:\n    """"""\n    Returns a JSON response.\n\n    This function takes in any number of positional arguments and keyword arguments,\n    which are then passed to the `json` method of the current application instance.\n    The result is a JSON response object.\n\n    Args:\n        *args (t.Any): Any positional arguments to be included in the response.\n        **kwargs (t.Any): Any keyword arguments to be included in the response.\n\n    Returns:\n        Response: A JSON response object.')","(False, ""```\nRecords a function to be executed once during the setup process.\n\nThis method is used to register a function that should only be executed once,\nduring the initial setup of the application. The function is wrapped in a\ndecorator to ensure it's only called once, even if the blueprint is reloaded.\n\nArgs:\n    func (DeferredSetupFunction): The function to be recorded and executed.\n    \nReturns:\n    None\n```"")","(True, '""""""\nWrapper function to handle first registration of users.\n\nThis function checks if the user has registered for the first time and calls the `func` function with the provided `state` object if so.\n\nArgs:\n    state (BlueprintSetupState): The current state of the application setup.\n\nReturns:\n    None\n""""""')"













"(True, '""""""\nLoads a Jinja template loader based on the presence of a template folder.\n\nReturns:\n    BaseLoader | None: A Jinja template loader instance if a template folder is present, otherwise None.\n""""""')"

"(False, 'def convert(\n    """"""\n    Converts the given environment variable value into a list of converted values.\n\n    Args:\n        value (t.Any): The environment variable value to be converted.\n        param (click.Parameter | None): The parameter object associated with the conversion.\n        ctx (click.Context | None): The context object containing additional information about the conversion.\n\n    Returns:\n        t.Any: A list of converted values.\n\n    Raises:\n        Exception: If an error occurs during the conversion process.\n    """"""\n    items = self.split_envvar_value(value)\n    # can\'t call no-arg super() inside list comprehension until Python 3.12\n    super_convert = super().convert\n    return [super_convert(item, param, ctx) for item in items]')","(True, '""""""\nReturns a context for the `run` command with the current file\'s path as an exclude pattern.\n\nThis function creates a context for the `run` command, passing the current file\'s path as an exclude pattern.\nThe resulting context is then asserted to have the expected exclude patterns.\n\nArgs:\n    None\n\nReturns:\n    A context object containing the `run` command parameters\n""""""')"








"(True, '""""""\nLocate an application within a given Flask module.\n\nThis function takes in the name of the module and the name of the application to locate.\nIt also accepts an optional parameter `raise_if_not_found` which defaults to `True`.\nIf `raise_if_not_found` is `False`, the function will return `None` instead of raising an exception if the application cannot be found.\n\nArgs:\n    module_name (str): The name of the Flask module to search in.\n    app_name (str | None): The name of the application to locate. If `None`, all applications in the module are returned.\n    raise_if_not_found (bool, optional): Whether to raise an exception if the application cannot be found. Defaults to `True`.\n\nReturns:\n    Flask: The located Flask application object.\n\nRaises:\n    ValueError: If `raise_if_not_found` is `False`.\n""""""')","(True, '""""""\nLocate an application within a given module.\n\nThis function searches for an application with the specified name within a given module.\nIt returns the found application or `None` if not found. If `raise_if_not_found` is set to `True`, it raises a `ValueError` if the application is not found.\n\nArgs:\n    - **module_name** (str): The name of the module to search in.\n    - **app_name** (str | None): The name of the application to locate. If `None`, all applications will be returned.\n    - **raise_if_not_found** (t.Literal[False] = ...): Whether to raise an error if the application is not found.\n\nReturns:\n    - Flask | None: The located application or `None` if not found.\n""""""')","(True, '""""""\nGets the instance of this descriptor.\n\nArgs:\n    obj (None): The object that owns this descriptor. If not provided, returns self.\n    owner (None): The class or type that defines this descriptor. If not provided, returns self.\n\nReturns:\n    te.Self: The instance of this descriptor.\n""""""')","(True, '""""""\nGets an attribute from an object.\n\nThis method is used to implement property access in Python. It allows you to define a getter function for a property of a class.\n\nArgs:\n    self (object): The instance of the class.\n    obj (App, optional): The object that owns this property. Defaults to None.\n    owner (type[App], optional): The type of the App class. Defaults to None.\n\nReturns:\n    T: The value of the attribute.\n""""""')","(True, '""""""\nTests the JSONification of UUID types.\n\nThis function tests that a UUID object can be successfully serialized to JSON and deserialized back into a UUID object.\n\nParameters:\napp (Flask application): The Flask application instance.\nclient (Flask client): The Flask client instance.\n\nReturns:\nNone\n""""""')","(True, '""""""\nSynchronizes data before any operations.\n\nThis function is intended to be called before any data synchronization or update operations.\nIt may include tasks such as cleaning up temporary files, resetting session variables, or performing other necessary steps to ensure a consistent state.\n\nArgs:\n    None\n\nReturns:\n    None\n""""""')","(True, '""""""\nAsync Function to be Executed Before Asynchronous Operations\n\nThis function is designed to be executed before any asynchronous operations. It serves as a placeholder or initialization point for tasks that need to be completed before proceeding with asynchronous code.\n\nArgs:\n    None\n\nReturns:\n    None\n""""""')","(True, '""""""\nTeardowns synchronization operations after an exception occurs.\n\nThis function is designed to be used as part of a larger error handling mechanism.\nIt takes an exception object as input and performs any necessary cleanup or rollback\nof the synchronization operation before continuing execution. If no exception occurred,\nit does nothing.\n\nParameters:\nexc (BaseException | None): The exception that occurred, or None if no exception occurred.\n\nReturns:\nNone: This function does not return a value.\n""""""')","(True, '""""""\nTeardowns an asynchronous operation.\n\nThis function is used to handle exceptions that occur during an asynchronous operation.\nIt provides a way to clean up resources and restore the original state of the system\nafter an exception has occurred.\n\nArgs:\n    exc (BaseException | None): The exception that occurred during the operation. Can be None if no exception occurred.\n\nReturns:\n    None\n\nRaises:\n    BaseException: If an error occurs while cleaning up resources.\n""""""')"
"(True, '""""""\nTests the JSONification of UUID types.\n\nThis function tests that a UUID object can be successfully serialized to JSON and deserialized back into a UUID object.\n\nParameters:\napp (Flask application): The Flask application instance.\nclient (Flask client): The Flask client instance.\n\nReturns:\nNone\n""""""')"



"(True, '""""""\nCalculates the SHA-1 hash of a given string.\n\nArgs:\n    string (bytes, optional): The input string to be hashed. Defaults to an empty byte string.\n\nReturns:\n    Any: The calculated SHA-1 hash as a bytes object.\n""""""')"


