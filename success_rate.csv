Success,Comment
"(True, '""""""\nLoads a Flask application instance.\n\nThis method attempts to load an existing Flask application from the `self._loaded_app` attribute,\nor creates a new one if none exists. It also sets the debug flag of the loaded application\nif `self.set_debug_flag` is True.\n\nIf no application can be found, it raises a `NoAppException`.\n\nReturns:\n    The loaded Flask application instance.\n""""""')"


"(True, '""""""\nTest session special types.\n\nThis function tests the behavior of Flask\'s session object when storing\nspecial types such as bytes, Markup objects, and UUIDs. It verifies that\nthese types are stored correctly and can be retrieved from the session.\n\nParameters:\napp (Flask application): The Flask application instance.\nclient (Client): The client instance used for testing.\n\nReturns:\nNone\n""""""')","(True, '""""""\nTest teardown request handler error functionality.\n\nThis test verifies that all teardown requests are passed the same original exception.\nIt also checks that a request with a division by zero error is handled correctly,\nand that an internal server error response is returned to the client.\n\nParameters:\napp (Flask application): The Flask application instance being tested.\nclient (requests session): The HTTP client used to make requests to the application.\n\nReturns:\nNone\n""""""')","(False, '""""""\nRaises a new `TypeError` exception to test that all teardown requests are passed the same original exception.\n\nThis function is designed to be used in conjunction with the `teardown_requests` context manager, which ensures that all teardown requests are executed regardless of whether an exception was raised or not. By raising a new exception and then catching it, this function verifies that the original exception is still available for teardown requests to access.\n\nArgs:\n    exc (Exception): The original exception that was raised during the request.\n\nReturns:\n    None\n""""""\ndef teardown_request1(exc):\n    assert type(exc) is ZeroDivisionError\n    called.append(True)\n    try:\n        raise TypeError()\n    except Exception:\n        pass')","(True, '""""""\nRaises a new `TypeError` exception to test that all teardown requests are passed the same original exception.\n\nThis function is designed to be used in conjunction with other teardown functions. It raises a new error and blows away sys.exc_info(), \nso we can test that all teardown_requests get passed the same original exception.\n\nArgs:\n    exc (Exception): The exception to be raised.\n\nReturns:\n    None\n\nRaises:\n    TypeError: A new `TypeError` exception is raised.\n""""""')"









"(False, '""""""\nConverts a given value to a timedelta object.\n\nIf the input is already a timedelta object, it returns the original object.\nOtherwise, it converts an integer or None value to a timedelta object representing the specified number of seconds.\n\nArgs:\n    value (timedelta | int | None): The value to be converted to a timedelta object.\n\nReturns:\n    timedelta | None: The converted timedelta object or None if the input is invalid.')","(False, '""""""\nInitialize a new Flask application instance.\n\nThis function initializes a new Flask application instance with the provided parameters. It sets up various attributes and methods that can be used throughout the application lifecycle.\n\nParameters:\n    import_name (str): The name of the module where this application is defined.\n    static_url_path (str | None): The URL path for serving static files. Defaults to None.\n    static_folder (str | os.PathLike | None): The folder containing static files. Defaults to ""static"".\n    static_host (str | None): The host for serving static files. Defaults to None.\n    host_matching (bool): Whether the application should match hosts in URLs. Defaults to False.\n    subdomain_matching (bool): Whether the application should match subdomains in URLs. Defaults to False.\n    template_folder (str | os.PathLike | None): The folder containing templates. Defaults to ""templates"".\n    instance_path (str | None): The path to the instance folder. If not provided, it will be automatically determined.\n    instance_relative_config (bool): Whether the configuration should be relative to the instance folder. Defaults to False.\n    root_path (str | None): The root path for the application. Defaults to None.\n\nAttributes:\n    instance_path (str): The path to the instance folder.\n    config (Config): The configuration dictionary as a Config object.\n    aborter (Aborter): An instance of Aborter created by make_aborter.\n    json (JSONProvider): A provider for JSON methods.\n    url_build_error_handlers (list[Callable[[Exception, str, dict[str, Any]], str]]): A list of functions that handle URL build errors.\n    teardown_appcontext_funcs (list[TeardownCallable]): A list of functions to run when the application context is destroyed.\n    shell_context_processors (list[ShellContextProcessorCallable]): A list of shell context processor functions.\n    blueprints (dict[str, Blueprint]): A dictionary mapping registered blueprint names to blueprint objects.\n    extensions (dict): A dictionary for storing application-specific state.\n    url_map (Map): The URL map for this instance.\n""""""\n\ndef __init__(\n        self,\n        import_name: str,\n        static_url_path: str | None = None,\n        static_folder: str | os.PathLike | None = ""static"",\n        static_host: str | None = None,\n        host_matching: bool = False,\n        subdomain_matching: bool = False,\n        template_folder: str | os.PathLike | None = ""templates"",\n        instance_path: str | None = None,\n        instance_relative_config: bool = False,\n        root_path: str | None = None,\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n        elif not os.path.isabs(instance_path):\n            raise ValueError(\n                ""If an instance path is provided it must be absolute.""\n                "" A relative path was given instead.""\n            )\n\n        #: Holds the path to the instance folder.\n        #:\n        #: .. versionadded:: 0.8\n        self.instance_path = instance_path\n\n        #: The configuration dictionary as :class:`Config`.  This behaves\n        #: exactly like a regular dictionary but supports additional methods\n        #: to load a config from files.\n        self.config = self.make_config(instance_relative_config)\n\n        #: An instance of :attr:`aborter_class` created by\n        #: :meth:`make_aborter`. This is called by :func:`flask.abort`\n        #: to raise HTTP errors, and can be called directly as well.\n        #:\n        #: .. versionadded:: 2.2\n        #:     Moved from ``flask.abort``, which calls this object.\n        self.aborter = self.make_aborter()\n\n        self.json: JSONProvider = self.json_provider_class(self)\n        """"""Provides access to JSON methods. Functions in ``flask.json``\n        will call methods on this provider when the application context\n        is active. Used for handling JSON requests and responses.\n\n        An instance of :attr:`json_provider_class`. Can be customized by\n        changing that attribute on a subclass, or by assigning to this\n        attribute afterwards.\n\n        The default, :class:`~flask.json.provider.DefaultJSONProvider`,\n        uses Python\'s built-in :mod:`json` library. A different provider\n        can use a different JSON library.\n\n        .. versionadded:: 2.2\n        """"""\n\n        #: A list of functions that are called by\n        #: :meth:`handle_url_build_error` when :meth:`.url_for` raises a\n        #: :exc:`~werkzeug.routing.BuildError`. Each function is called\n        #: with ``error``, ``endpoint`` and ``values``. If a function\n        #: returns ``None`` or raises a ``BuildError``, it is skipped.\n        #: Otherwise, its return value is returned by ``url_for``.\n        #:\n        #: .. versionadded:: 0.9\n        self.url_build_error_handlers: list[\n            t.Callable[[Exception, str, dict[str, t.Any]], str]\n        ] = []\n\n        #: A list of functions that are called when the application context\n        #: is destroyed.  Since the application context is also torn down\n        #: if the request ends this is the place to store code that disconnects\n        #: from databases.\n        #:\n        #: .. versionadded:: 0.9\n        self.teardown_appcontext_funcs: list[ft.TeardownCallable] = []\n\n        #: A list of shell context processor functions that should be run\n        #: when a shell context is created.\n        #:\n        #: .. versionadded:: 0.11\n        self.shell_context_processors: list[ft.ShellContextProcessorCallable] = []\n\n        #: Maps registered blueprint names to blueprint objects. The\n        #: dict retains the order the blueprints were registered in.\n        #: Blueprints can be registered multiple times, this dict does\n        #: not track how often they were attached.\n        #:\n        #: .. versionadded:: 0.7\n        self.blueprints: dict[str, Blueprint] = {}\n\n        #: a place where extensions can store application specific state.  For\n        #: example this is where an extension could store database engines and\n        #: similar things.\n        #:\n        #: The key must match the name of the extension module. For example in\n        #: case of a ""Flask-Foo"" extension in `flask_foo`, the key would be\n        #: ``\'foo\'``.\n        #:\n        #: .. versionadded:: 0.7\n        self.extensions: dict = {}\n\n        #: The :class:`~werkzeug.routing.Map` for this instance.  You can use\n        #: this to change the routing converters after the class was created\n        #: but before any routes are connected.  Example::\n        #:\n        #:    from werkzeug.routing import BaseConverter\n        #:\n        #:    class ListConverter(BaseConverter):\n        #:        def to_python(self, value):\n        #:            return value.split(\',\')\n        #:        def to_url(self, values):\n        #:            return \',\'.join(super(ListConverter, self).to_url(value)\n        #:                            for value in values)\n        #:\n        #:    app = Flask(__name__)\n        #:    app.url_map.converters[\'list\'] = ListConverter\n        self.url_map = self.url_map_class()\n\n        self.url_map.host_matching = host_matching\n        self.subdomain_matching = subdomain_matching\n\n        # tracks internally if the application already handled at least one\n        # request.\n        self._got_first_request = False\n\n        # Add a static route using the provided static_url_path, static_host,\n        # and static_folder if there is a configured static_folder.\n        # Note we do this without checking if static_folder exists.\n        # For one, it might be created while the server is running (e.g. during\n        # development). Also, Google App Engine stores static files somewhere\n        if self.has_static_folder:\n            assert (\n                bool(static_host) == host_matching\n            ), ""Invalid static_host/host_matching combination""\n            # Use a weakref to avoid creating a reference cycle between the app\n            # and the view function (see #3761).\n            self_ref = weakref.ref(self)\n            self.add_url_rule(\n                f""{self.static_url_path}/<path:filename>"",\n                endpoint=""static"",\n                host=static_host,\n                view_func=lambda **kw: self_ref().send_static_file(**kw),  # type: ignore # noqa: B950\n            )\n\n        # Set the name of the Click group in case someone wants to add\n        # the app\'s commands to another CLI tool.\n        self.cli.name = self.name')","(True, '""""""\nRaises an AssertionError if the setup method has already been called on the application.\n\nThis check is performed after the first request has been handled by the application.\nIf the setup method is called again, any changes made will not be applied consistently.\n\nParameters:\n    f_name (str): The name of the setup method being checked.\n\nReturns:\n    None\n\nRaises:\n    AssertionError: If the setup method has already been called on the application.\n""""""')","(True, '""""""\nReturns the name of the current module or the main module name if running directly.\n\nIf running directly, it attempts to retrieve the filename from the `__file__` attribute of the main module.\nIf successful, it returns the base filename without extension. Otherwise, it returns the main module name.\n\nArgs:\n    None\n\nReturns:\n    str: The name of the current module or the main module name if running directly.\n""""""')","(True, '""""""\nReturns an instance of the Logger class.\n\nThis method is used to initialize and return a new logger object. The logger object is created using the `create_logger` function, which takes the current object (`self`) as an argument.\n\nArgs:\n    self: The current object.\n\nReturns:\n    logging.Logger: An instance of the Logger class.\n""""""')","(True, '""""""\nReturns an instance of Jinja2\'s Environment class.\n\nThis method is a wrapper around `create_jinja_environment` and provides a more Pythonic interface for creating a new Jinja environment. The returned environment can be used to compile templates, render templates with data, and perform other template-related tasks.\n\nNote: This method does not create a new environment instance; it simply delegates the creation to the underlying `create_jinja_environment` method.\n""""""')","(True, '""""""\nCreates a configuration object based on the provided parameters.\n\nArgs:\n    instance_relative (bool): If True, uses the instance\'s path instead of the root path. Defaults to False.\n\nReturns:\n    Config: A configuration object with the specified settings.\n""""""')","(True, '""""""\nCreates an instance of the Aborter class.\n\nReturns:\n    Aborter: An instance of the Aborter class.\n""""""')","(False, 'def auto_find_instance_path(self) -> str:\n    """"""\n    Returns the path to the instance directory based on the package and import name.\n\n    If the package is not found, it defaults to the \'instance\' directory in the package path.\n    Otherwise, it returns a subdirectory named after the class name with \'-instance\' appended.\n\n    Args:\n        self: The object instance containing the import_name attribute.\n\n    Returns:\n        str: The full path to the instance directory.\n    """"""')","(True, '""""""\nOpens an instance resource file.\n\nArgs:\n    - `resource` (str): The path to the resource file.\n    - `mode` (str, optional): The mode in which to open the file. Defaults to ""rb"".\n\nReturns:\n    A file object opened at the specified location with the given mode.\n\nRaises:\n    FileNotFoundError: If the instance_path does not exist or the resource is not found.\n""""""')","(True, '""""""\nCreates a Jinja environment with custom options and updates its globals.\n\nThis method creates a new Jinja environment based on the provided options.\nIt also updates the environment\'s globals dictionary to include necessary functions\nand variables for use in templates.\n\nArgs:\n    self: The object instance that owns this method.\n\nReturns:\n    Environment: A newly created Jinja environment with custom options and updated globals.\n""""""')","(True, '""""""\nCreates and returns a global Jinja loader instance.\n\nThis method is used to initialize the global Jinja loader, which is then used throughout the application.\nIt takes no arguments and returns an instance of `DispatchingJinjaLoader`, which is responsible for dispatching template rendering tasks.\n\nReturns:\n    DispatchingJinjaLoader: A global Jinja loader instance.\n""""""')","(True, '""""""\nSelects whether a Jinja autoescape should be applied to a given file.\n\nArgs:\n    filename (str): The name of the file to check.\n\nReturns:\n    bool: True if the file should have autoescape applied, False otherwise.\n""""""')","(True, '""""""\nUpdates the template context with additional information.\n\nThis function is used to extend the context passed to a template, allowing\nfor dynamic rendering of templates outside of a request context. It first\nchecks if a request object is available and adds any blueprint names from\nit to the list of names to process. Then it iterates over this list,\napplying any context processors that have been registered for each name.\n\nThe original context is preserved and updated with the new values after all\ncontext processors have been applied.\n\nArgs:\n    context (dict): The initial template context.\n\nReturns:\n    None\n""""""')","(True, '""""""\nReturns a dictionary representing the shell context.\n\nThis function combines the application object (`self`) with the global object (`g`), \nand then updates it with the results of each processor function in `self.shell_context_processors`.\n\nArgs:\n    None\n\nReturns:\n    dict: The constructed shell context.\n""""""')","(True, '""""""\nReturns whether the debug mode is enabled based on the configuration.\n\nArgs:\n    None\n\nReturns:\n    bool: True if debug mode is enabled, False otherwise\n""""""')","(True, '""""""\n    Sets the debug mode for the application.\n\n    Args:\n        value (bool): A boolean indicating whether to enable or disable debug mode.\n    \n    Returns:\n        None\n    \n    Note:\n        This function modifies the configuration of the application. It also affects the behavior of the Jinja templating engine if TEMPLATES_AUTO_RELOAD is not set.\n""""""')","(False, '```python\ndef run(\n    host: str | None = None,\n    port: int | None = None,\n    debug: bool | None = None,\n    load_dotenv: bool = True,\n    **options: t.Any,\n) -> None:\n    """"""\n    Run the Flask development server.\n\n    This function is used to start a Flask development server. It takes several\n    optional parameters, including `host`, `port`, and `debug`. If `load_dotenv`\n    is set to True, it loads environment variables from a .env file. The `debug`\n    parameter can be set to override the default debug mode.\n\n    Args:\n        host (str | None): The hostname or IP address to bind to.\n        port (int | None): The port number to use.\n        debug (bool | None): Whether to enable debug mode.\n        load_dotenv (bool, optional): Whether to load environment variables from a .env file. Defaults to True.\n        **options: t.Any: Additional options for the server.\n\n    Returns:\n        None\n    """"""\n```')","(True, '""""""\nReturns a test client instance for the application.\n\nArgs:\n    use_cookies (bool): Whether to include cookies in the request. Defaults to True.\n    **kwargs: Additional keyword arguments to pass to the FlaskClient constructor.\n\nReturns:\n    FlaskClient: A test client instance for the application.\n""""""')","(True, '""""""\nReturns an instance of `FlaskCliRunner` initialized with the provided keyword arguments.\n\nArgs:\n    **kwargs (t.Any): Keyword arguments to be passed to the `FlaskCliRunner` constructor.\n\nReturns:\n    FlaskCliRunner: An instance of `FlaskCliRunner`.\n\nRaises:\n    None\n""""""')","(True, '""""""\nRegisters a blueprint with the current application.\n\nArgs:\n    - blueprint (Blueprint): The blueprint to be registered.\n    - **options (t.Any): Optional keyword arguments to be passed to the `register` method of the blueprint.\n\nReturns:\n    None\n""""""')","(True, '""""""\nReturns an iterator over the blueprint values.\n\nThis method provides a view of all blueprints in the system, allowing for efficient iteration and access to their attributes. The returned iterator is a `ValuesView` object, which supports various methods for filtering and manipulating the results.\n\nArgs:\n    None\n\nReturns:\n    t.ValuesView[Blueprint]: An iterator over the blueprint values.\n""""""')","(False, 'def add_url_rule(\n    """"""\n    Adds a new URL rule to the application\'s URL map.\n\n    This method allows you to define a route for a specific endpoint, \n    which can be used to handle HTTP requests. The endpoint is optional, \n    and if not provided, it will be inferred from the view function.\n\n    Args:\n        rule (str): The URL pattern for the new route.\n        endpoint (str | None): The endpoint for the new route. Defaults to None.\n        view_func (ft.RouteCallable | None): The view function for the new route. Defaults to None.\n        provide_automatic_options (bool | None): Whether to automatically add OPTIONS and other methods to the route. Defaults to None.\n        **options: t.Any: Additional options for the URL rule.\n\n    Returns:\n        None\n    """"""\n    if endpoint is None:\n        endpoint = _endpoint_from_view_func(view_func)  # type: ignore\n    options[""endpoint""] = endpoint\n    methods = options.pop(""methods"", None)\n\n    # if the methods are not given and the view_func object knows its\n    # methods we can use that instead.  If neither exists, we go with\n    # a tuple of only ``GET`` as default.\n    if methods is None:\n        methods = getattr(view_func, ""methods"", None) or (""GET"",)\n    if isinstance(methods, str):\n        raise TypeError(\n            ""Allowed methods must be a list of strings, for""\n            \' example: @app.route(..., methods=[""POST""])\'\n        )\n    methods = {item.upper() for item in methods}\n\n    # Methods that should always be added\n    required_methods = set(getattr(view_func, ""required_methods"", ()))\n\n    # starting with Flask 0.8 the view_func object can disable and\n    # force-enable the automatic options handling.\n    if provide_automatic_options is None:\n        provide_automatic_options = getattr(\n            view_func, ""provide_automatic_options"", None\n        )\n\n    if provide_automatic_options is None:\n        if ""OPTIONS"" not in methods:\n            provide_automatic_options = True\n            required_methods.add(""OPTIONS"")\n        else:\n            provide_automatic_options = False\n\n    # Add the required methods now.\n    methods |= required_methods\n\n    rule = self.url_rule_class(rule, methods=methods, **options)\n    rule.provide_automatic_options = provide_automatic_options  # type: ignore\n\n    self.url_map.add(rule)\n    if view_func is not None:\n        old_func = self.view_functions.get(endpoint)\n        if old_func is not None and old_func != view_func:\n            raise AssertionError(\n                ""View function mapping is overwriting an existing""\n                f"" endpoint function: {endpoint}""\n            )\n        self.view_functions[endpoint] = view_func')","(False, '""""""\nTemplate Filter Decorator\n\nThis function is a decorator factory that creates a template filter with the given name.\n\nArgs:\n    name (str | None): The name of the template filter. If None, no name will be assigned.\n\nReturns:\n    T_template_filter: A callable that returns the decorated template filter.\n""""""\n\ndef template_filter(\n        self, name: str | None = None\n) -> t.Callable[[T_template_filter], T_template_filter]:\n\n    def decorator(f: T_template_filter) -> T_template_filter:\n        """"""\n        Decorator function to add a template filter.\n\n        Args:\n            f (T_template_filter): The template filter to be decorated.\n\n        Returns:\n            T_template_filter: The decorated template filter.\n        """"""\n        self.add_template_filter(f, name=name)\n        return f\n\n    return decorator')","(True, '""""""\nAdds a template filter to the current context.\n\nThis function is a decorator that takes a template filter as an argument and adds it to the current context.\nThe added filter will be accessible under the specified `name` parameter.\n\nArgs:\n    f (T_template_filter): The template filter to add to the context.\n\nReturns:\n    T_template_filter: The original filter, now decorated with the added functionality.\n\nRaises:\n    ValueError: If the name is not a valid identifier.\n""""""')","(True, '""""""\nAdds a template filter to the Jinja environment.\n\nArgs:\n    f (ft.TemplateFilterCallable): The filter function to add.\n    name (str, optional): The name of the filter. If None, uses the function\'s __name__. Defaults to None.\n\nReturns:\n    None\n""""""')","(True, '""""""\nTemplate Test Decorator.\n\nThis function returns a decorator that can be used to wrap a template test function.\nThe wrapped function will have its `name` attribute set by the `template_test` function.\n\nArgs:\n    f (Callable[[T_template_test], T_template_test]): The function to be decorated.\n    name (str | None, optional): The name of the template test. Defaults to None.\n\nReturns:\n    Callable[[T_template_test], T_template_test]: The decorated function.\n""""""')","(False, '""""""\nDecorates a test function with template testing.\n\nThis function takes a test function `f` as input and adds it to the template tests.\nThe decorated function is then returned.\n\nArgs:\n    f (T_template_test): The test function to be decorated.\n\nReturns:\n    T_template_test: The decorated test function.\n\nRaises:\n    None\n""""""\ndef decorator(f: T_template_test) -> T_template_test:\n    self.add_template_test(f, name=name)\n    return f')","(True, '""""""\nAdds a template test to the Jinja environment.\n\nArgs:\n    - `f`: A callable representing the template test.\n    - `name` (optional): The name of the test. If not provided, it defaults to the function\'s name.\n\nReturns:\n    None\n""""""')","(True, '""""""\nTemplate Global Decorator\n\nThis function is used to create a template global decorator. It takes a function `f` as an argument and returns the same function wrapped with the `add_template_global` method.\n\nThe `name` parameter can be provided to specify the name of the template global. If not specified, it defaults to None.\n\nArgs:\n    f (T_template_global): The function to be decorated.\n    name (str | None, optional): The name of the template global. Defaults to None.\n\nReturns:\n    T_template_global: The decorated function.\n""""""')","(True, '""""""\nDecorates a function to add it as a template global.\n\nArgs:\n    f (T_template_global): The function to be decorated.\n\nReturns:\n    T_template_global: The decorated function.\n""""""')","(True, '""""""\nAdds a template global to the Jinja environment.\n\nThis method allows you to add a callable as a global variable in the Jinja environment.\nThe callable can be used in templates using the `{{ }}` syntax, and its name will be used as the key for the global variable.\n\nArgs:\n    f (ft.TemplateGlobalCallable): The callable to add as a global variable.\n    name (str | None, optional): The name of the global variable. If not provided, the name of the callable will be used. Defaults to None.\n\nReturns:\n    None\n""""""')","(True, '""""""\nAdds a teardown function to the list of teardown functions and returns the original function.\n\nArgs:\n    f (T_teardown): The teardown function to be added.\n\nReturns:\n    T_teardown: The original teardown function.\n""""""')","(True, '""""""\nProcessors for shell context.\n\nThis function is used to register a shell context processor. The processor will be executed when the shell context is processed.\n\nArgs:\n    f (T_shell_context_processor): The processor to be registered.\n\nReturns:\n    T_shell_context_processor: The original processor, which has been appended to the list of shell context processors.\n""""""')","(True, '""""""\nFinds the error handler for a given exception.\n\nThis function iterates through the blueprint handlers and class-specific handlers to find a matching error handler.\nIf no match is found, it returns `None`.\n\nArgs:\n    e (Exception): The exception for which to find an error handler.\n\nReturns:\n    ft.ErrorHandlerCallable | None: The error handler for the given exception, or `None` if no match is found.\n""""""')","(False, '""""""\nHandles HTTP exceptions by checking their type and returning them accordingly.\n\nIf the exception has no error code, it is returned unchanged as an error.\nIf the exception is a RoutingException, it is also returned unchanged.\nOtherwise, an error handler is found using `_find_error_handler` and the result of calling `ensure_sync` on this handler is returned.')","(True, '""""""\nTraps HTTP exceptions based on configuration settings.\n\nThis function determines whether to trap an HTTP exception or not. It checks the `TRAP_HTTP_EXCEPTIONS` setting in the application\'s configuration.\nIf this setting is enabled, the function returns True, indicating that the exception should be trapped.\n\nAdditionally, if `TRAP_BAD_REQUEST_ERRORS` is set to None and the application is in debug mode, key errors are also trapped.\n\nFinally, if `TRAP_BAD_REQUEST_ERRORS` is enabled, only bad request exceptions are trapped. Otherwise, no exceptions are trapped.\n\nArgs:\n    e (Exception): The exception to check.\n\nReturns:\n    bool: True if the exception should be trapped, False otherwise.\n""""""')","(False, '""""""\nHandles exceptions raised by the user.\n\nThis function checks for specific exception types and decides how to handle them.\nIf a `BadRequestKeyError` occurs and debug mode or the trap bad request errors config flag are set, it sets the `show_exception` attribute of the error object.\nIt then checks if an HTTPException occurred and is not being trapped. If so, it calls the `handle_http_exception` method to handle the exception.\nIf no error handler can be found for the given exception, it raises the exception again.\nOtherwise, it calls the error handler function with the exception as an argument.\n\nArgs:\n    e (Exception): The exception that was raised by the user.\n\nReturns:\n    HTTPException | ft.ResponseReturnValue: The handled exception or response value.')","(True, '""""""\nHandles exceptions raised during request processing.\n\nRaises an exception if propagation is enabled and the current exception\nis different from the one passed in. Otherwise, re-raises the original\nexception. If no error handler is found, logs the exception and returns a\nserver error response.\n\nArgs:\n    e (Exception): The exception to be handled.\n\nReturns:\n    Response: A server error response.\n""""""')","(True, '""""""\nLogs an exception with the provided error information.\n\nArgs:\n    - `self`: The instance of the class that this method belongs to.\n    - `exc_info`: A tuple containing the type, value, and traceback of the exception. Can be a single value if only one is available (e.g., for sys.exc_info()).\n\nReturns:\n    None\n""""""')","(False, '""""""\nRaises a routing exception if the request is not debuggable, \nor if it\'s a redirect with an invalid status code or method.\n\nArgs:\n    request (Request): The incoming HTTP request.\n\nReturns:\n    None\n""""""\ndef raise_routing_exception(self, request: Request) -> t.NoReturn:\n    ...\n')","(False, 'def dispatch_request(self) -> ft.ResponseReturnValue:\n    """"""\n    Dispatches a request to the corresponding endpoint.\n\n    If automatic options are provided for the URL and the request is an OPTIONS method,\n    it returns a default options response. Otherwise, it calls the view function with\n    the provided view arguments.\n\n    :return: The response from the dispatched view function.\n    """"""')","(True, '""""""\nDispatches the full request and handles any exceptions that may occur.\n\nThis method initiates the request dispatching process, ensuring that all necessary steps are taken to fulfill the user\'s request.\nIt also catches any exceptions that may be raised during this process and handles them accordingly.\n\nReturns:\n    Response: The response object after successful request dispatching or exception handling.\n\nRaises:\n    Exception: If an error occurs during request dispatching or exception handling.\n""""""')","(True, '""""""\nFinalizes a request by processing the response and sending a signal to indicate that the request has finished.\n\nArgs:\n    rv (ft.ResponseReturnValue | HTTPException): The response value or exception to be finalized.\n    from_error_handler (bool, optional): Whether this is being called from an error handler. Defaults to False.\n\nReturns:\n    Response: The finalized response object.\n\nRaises:\n    Exception: If the request finalizing fails and `from_error_handler` is False.\n""""""')","(True, '""""""\nReturns a default options response for the current request.\n\nThis method creates a new response object with the allowed HTTP methods from the URL adapter.\nThe `allow` attribute of the response is updated to include these methods, allowing the client to specify which methods are supported by the server.\n\nArgs:\n    None\n\nReturns:\n    Response: A new response object with the default options configuration.\n""""""')","(True, '""""""\nDetermines whether an exception should be ignored.\n\nArgs:\n    error (BaseException | None): The exception to check. Can be None for no exception.\nReturns:\n    bool: True if the exception should be ignored, False otherwise.\n""""""')","(True, '""""""\nEnsures that a provided function is synchronous by converting it to a synchronous function if it\'s a coroutine.\n\nArgs:\n    func (t.Callable): The function to be ensured as synchronous.\n\nReturns:\n    t.Callable: The synchronous version of the input function, or the original function if it\'s already synchronous.\n""""""')","(True, '""""""\nConverts an asynchronous function to a synchronous one.\n\nThis function takes an asynchronous callable and returns a new function that can be called synchronously.\nIt uses the `asgiref.sync.async_to_sync` function from Flask, which is only available when Flask is installed with the \'async\' extra.\n\nIf the required import fails, it raises a RuntimeError indicating that Flask needs to be installed with the \'async\' extra.\n\nArgs:\n    func: The asynchronous function to convert.\n\nReturns:\n    A new synchronous function wrapping the original asynchronous one.\n""""""')","(False, 'def url_for(\n    """"""\n    Generates a URL for the given endpoint.\n\n    This function is used to generate URLs for endpoints in a Flask application.\n    It takes into account various parameters such as scheme, domain, and anchor,\n    and returns a fully qualified URL.\n\n    Args:\n        endpoint (str): The endpoint for which to generate the URL.\n        _anchor (str | None): An optional anchor for the URL. Defaults to None.\n        _method (str | None): The HTTP method for the URL. Defaults to None.\n        _scheme (str | None): The scheme for the URL. Defaults to None.\n        _external (bool | None): Whether the URL is external or not. Defaults to None.\n        **values: t.Any**: Additional values to include in the URL.\n\n    Returns:\n        str: The generated URL.\n\n    Raises:\n        RuntimeError: If unable to build URLs outside an active request without \'SERVER_NAME\' configured.\n        ValueError: If \'_scheme\' is specified when \'_external\' is False.\n    """"""\n) -> str:\n    req_ctx = _cv_request.get(None)\n\n    if req_ctx is not None:\n        url_adapter = req_ctx.url_adapter\n        blueprint_name = req_ctx.request.blueprint\n\n        # If the endpoint starts with ""."" and the request matches a\n        # blueprint, the endpoint is relative to the blueprint.\n        if endpoint[:1] == ""."":\n            if blueprint_name is not None:\n                endpoint = f""{blueprint_name}{endpoint}""\n            else:\n                endpoint = endpoint[1:]\n\n        # When in a request, generate a URL without scheme and\n        # domain by default, unless a scheme is given.\n        if _external is None:\n            _external = _scheme is not None\n    else:\n        app_ctx = _cv_app.get(None)\n\n        # If called by helpers.url_for, an app context is active,\n        # use its url_adapter. Otherwise, app.url_for was called\n        # directly, build an adapter.\n        if app_ctx is not None:\n            url_adapter = app_ctx.url_adapter\n        else:\n            url_adapter = self.create_url_adapter(None)\n\n        if url_adapter is None:\n            raise RuntimeError(\n                ""Unable to build URLs outside an active request""\n                "" without \'SERVER_NAME\' configured. Also configure""\n                "" \'APPLICATION_ROOT\' and \'PREFERRED_URL_SCHEME\' as""\n                "" needed.""\n            )\n\n        # When outside a request, generate a URL with scheme and\n        # domain by default.\n        if _external is None:\n            _external = True\n\n    # It is an error to set _scheme when _external=False, in order\n    # to avoid accidental insecure URLs.\n    if _scheme is not None and not _external:\n        raise ValueError(""When specifying \'_scheme\', \'_external\' must be True."")\n\n    self.inject_url_defaults(endpoint, values)\n\n    try:\n        rv = url_adapter.build(  # type: ignore[union-attr]\n            endpoint,\n            values,\n            method=_method,\n            url_scheme=_scheme,\n            force_external=_external,\n        )\n    except BuildError as error:\n        values.update(\n            _anchor=_anchor, _method=_method, _scheme=_scheme, _external=_external\n        )\n        return self.handle_url_build_error(error, endpoint, values)\n\n    if _anchor is not None:\n        _anchor = _url_quote(_anchor, safe=""%!#$&\'()*+,/:;=?@"")\n        rv = f""{rv}#{_anchor}""\n\n    return rv')","(True, '""""""\nRedirects to a specified URL with an optional HTTP status code.\n\nArgs:\n    location (str): The URL to redirect to.\n    code (int, optional): The HTTP status code. Defaults to 302.\n\nReturns:\n    BaseResponse: A response object containing the redirect URL and status code.\n""""""')","(False, 'def make_response(self, rv: ft.ResponseReturnValue) -> Response:\n    """"""\n    Creates a response object from the given view function result.\n\n    The response object is created based on the type of the view function result.\n    If the result is a tuple, it is unpacked into body, status, and headers.\n    If the result is None, a TypeError is raised.\n    If the result is not an instance of the response class, it is converted to\n    the correct type.\n\n    Args:\n        rv: The view function result.\n\n    Returns:\n        A Response object.\n\n    Raises:\n        TypeError: If the view function did not return a valid response tuple,\n            or if the result is None.\n    """"""')","(True, '""""""\nCreates a URL adapter for the current request.\n\nIf `subdomain_matching` is disabled, uses the default subdomain in all cases.\nOtherwise, does not use a subdomain. The adapter binds to the environment,\nserver name, and other configuration settings from the application\'s config.\n\nReturns:\n    MapAdapter | None: A bound URL map adapter or None if no adapter can be created.\n""""""')","(False, 'def inject_url_defaults(self, endpoint: str, values: dict) -> None:\n    """"""\n    Injects URL defaults into the given endpoint.\n\n    This function is used to populate URL parameters with default values.\n    It can be called outside of a request context and will parse the\n    passed endpoint accordingly. The function iterates over the names\n    in the `self.url_default_functions` dictionary, calling each function\n    for the corresponding name with the given endpoint and values.\n\n    Args:\n        endpoint (str): The URL endpoint to inject defaults into.\n        values (dict): A dictionary of values to be injected into the endpoint.\n\n    Returns:\n        None\n    """"""')","(False, '""""""\nHandles URL build errors by iterating over a list of handlers and attempting to resolve the issue.\n\nArgs:\n    - self: The instance of the class that contains this method.\n    - error (BuildError): The error encountered during URL building.\n    - endpoint (str): The endpoint being built.\n    - values (dict[str, t.Any]): A dictionary of values used in the URL build process.\n\nReturns:\n    str: The resolved URL or None if no handler could resolve it.\n\nRaises:\n    BuildError: If an active exception is encountered and cannot be re-raised.\n""""""\ndef handle_url_build_error(\n        self, error: BuildError, endpoint: str, values: dict[str, t.Any]\n    ) -> str:\n        for handler in self.url_build_error_handlers:\n            try:\n                rv = handler(error, endpoint, values)\n            except BuildError as e:\n                # make error available outside except block\n                error = e\n            else:\n                if rv is not None:\n                    return rv\n\n        # Re-raise if called with an active exception, otherwise raise\n        # the passed in exception.\n        if error is sys.exc_info()[1]:\n            raise\n\n        raise error')","(True, '""""""\nPreprocesses the request by applying URL value preprocessors and before request functions.\n\nThis method iterates over the blueprint names in reverse order, applying any URL value preprocessors to each endpoint.\nIt then checks for any before request functions associated with the current blueprint and executes them if present.\n\nIf a before request function returns a non-None response, it is returned immediately. Otherwise, the method proceeds to check the next blueprint.\n\nReturns:\n    ft.ResponseReturnValue | None: The result of the last executed before request function, or None if no such function was found.\n""""""')","(True, '""""""\nProcesses the given response by executing any after-request functions and saving the session.\n\nArgs:\n    response (Response): The response to be processed.\n\nReturns:\n    Response: The processed response.\n""""""')","(False, '""""""\n    Performs teardown operations for the current request.\n\n    This function is responsible for executing any necessary cleanup or rollback\n    actions after a request has been completed. It iterates through the available\n    teardown functions and executes them in reverse order to ensure that resources\n    are properly cleaned up before moving on to the next one.\n\n    Args:\n        exc (BaseException | None): The exception being handled, if any.\n            Defaults to `_sentinel` to avoid raising an exception during initialization.\n    """"""\ndef do_teardown_request(\n    self, \n    exc: BaseException | None = _sentinel  # type: ignore\n) -> None:\n    ...\n')","(True, '""""""\nTear down the application context.\n\nThis function is called after the application context has been torn down. It ensures that any teardown functions are executed in a synchronous manner and sends an event to notify other parts of the application that the context is being torn down.\n\nArgs:\n    exc (BaseException | None): The exception that caused the tear down, or None if no exception was raised.\n        Defaults to `_sentinel` which will be replaced with the actual exception if present.\n\nReturns:\n    None\n""""""')","(True, '""""""\nReturns an instance of `AppContext` initialized with the current object.\n\nArgs:\n    None\n\nReturns:\n    AppContext: An instance of `AppContext` initialized with the current object.\n""""""')","(True, '""""""\nReturns a new instance of RequestContext with the given environment.\n\nArgs:\n    environ (dict): The current HTTP environment.\n\nReturns:\n    RequestContext: A new instance of RequestContext.\n""""""')","(True, '""""""\nTests the creation of a request context using an `EnvironBuilder`.\n\nThis function creates an instance of `EnvironBuilder` with the provided arguments,\nuses it to create an environment, and then attempts to create a request context\nusing that environment. The `finally` block ensures the `EnvironBuilder` is properly\nclosed after use.\n\nArgs:\n    *args: Variable number of positional arguments to pass to the `EnvironBuilder`.\n    **kwargs: Keyword arguments to pass to the `EnvironBuilder`.\n\nReturns:\n    A `RequestContext` object representing the created request context.\nRaises:\n    Exception: If an error occurs while creating the request context.\n""""""')","(True, '""""""\nWSGI Application Function\n\nThis function serves as the entry point for the WSGI application. It takes in an environment dictionary and a start response callable, \nand returns any response object generated by the application.\n\nThe function first creates a request context using `self.request_context(environ)`. It then attempts to execute the full dispatch of the request,\nhandling any exceptions that may occur during this process. If an exception is caught, it will be handled and propagated up the call stack.\nFinally, the response object is returned to the caller.\n\nNote: This function should not be called directly by users of the application. Instead, it should be used as part of a larger WSGI server or framework.\n""""""')","(True, '""""""\n    Calls the WSGI application with the provided environment and response callback.\n\n    Args:\n        environ (dict): The HTTP request environment.\n        start_response (t.Callable): A callable that takes a status code and headers as arguments.\n\n    Returns:\n        t.Any: The result of calling the WSGI application.\n\n    Note:\n        This method is part of the WSGI protocol and is used to call the WSGI application with the provided environment and response callback.\n""""""')","(False, 'def __init__(\n    """"""\n    Initializes a new instance of the BlueprintSetupState class.\n\n    This method is called when an application is created and it\'s necessary to\n    set up the blueprint state. It takes in several parameters, including the\n    Flask app, the Blueprint object, options for the blueprint, and a boolean\n    indicating whether this is the first registration of the blueprint.\n\n    Args:\n        blueprint (Blueprint): A reference to the blueprint that created this setup state.\n        app (Flask): A reference to the current application.\n        options (t.Any): A dictionary with all options that were passed to the register_blueprint method.\n        first_registration (bool): As blueprints can be registered multiple times with the application and not everything wants to be registered multiple times on it, this attribute can be used to figure out if the blueprint was registered in the past already.\n\n    Returns:\n        None\n    """"""\n    self.app = app\n    self.blueprint = blueprint\n    self.options = options\n    self.first_registration = first_registration\n\n    subdomain = self.options.get(""subdomain"")\n    if subdomain is None:\n        subdomain = self.blueprint.subdomain\n\n    self.subdomain = subdomain\n\n    url_prefix = self.options.get(""url_prefix"")\n    if url_prefix is None:\n        url_prefix = self.blueprint.url_prefix\n    self.url_prefix = url_prefix\n\n    self.name = self.options.get(""name"", blueprint.name)\n    self.name_prefix = self.options.get(""name_prefix"", """")\n\n    self.url_defaults = dict(self.blueprint.url_values_defaults)\n    self.url_defaults.update(self.options.get(""url_defaults"", ()))')","(True, '""""""\nAdds a URL rule to the application.\n\nParameters:\n    rule (str): The URL pattern.\n    endpoint (str | None, optional): The endpoint name. Defaults to None.\n    view_func (t.Callable | None, optional): The view function. Defaults to None.\n    **options (t.Any): Additional options for the URL rule.\n\nReturns:\n    None\n""""""')","(True, '""""""\nInitialize a Flask Blueprint.\n\nThis function initializes a new Flask Blueprint with the given parameters. It sets up the blueprint\'s metadata and configuration options.\n\nParameters:\n    name (str): The name of the blueprint.\n    import_name (str): The import name of the blueprint.\n    static_folder (str | os.PathLike | None, optional): The folder containing static files. Defaults to None.\n    static_url_path (str | None, optional): The URL path for static files. Defaults to None.\n    template_folder (str | os.PathLike | None, optional): The folder containing templates. Defaults to None.\n    url_prefix (str | None, optional): The prefix for URLs. Defaults to None.\n    subdomain (str | None, optional): The subdomain for the blueprint. Defaults to None.\n    url_defaults (dict | None, optional): Default values for URL parameters. Defaults to None.\n    root_path (str | None, optional): The root path of the blueprint. Defaults to None.\n    cli_group (str | None, optional): The CLI group for the blueprint. Defaults to _sentinel.\n\nRaises:\n    ValueError: If \'name\' is empty or contains a dot \'.\' character.\n\nAttributes:\n    name (str): The name of the blueprint.\n    url_prefix (str): The prefix for URLs.\n    subdomain (str): The subdomain for the blueprint.\n    deferred_functions (list[DeferredSetupFunction]): A list of deferred setup functions.\n    url_values_defaults (dict): Default values for URL parameters.\n    cli_group (str): The CLI group for the blueprint.\n    _blueprints (list[tuple[Blueprint, dict]]): A list of blueprints and their configurations.\n\n""""""')","(True, '""""""\nRaises an AssertionError if the setup method has already been registered.\n\nIf the setup method has been called at least once, this function will raise\nan AssertionError with a message indicating that further calls to the setup\nmethod will not be applied consistently. This is intended to prevent changes\nto imports, decorators, functions, etc. from being made after registration.\n\nArgs:\n    f_name (str): The name of the setup method that was called.\n\nRaises:\n    AssertionError: If the setup method has already been registered.\n""""""')","(False, '""""""\nRecords a callable function to be executed later.\n\nArgs:\n    func (t.Callable): The function to be recorded.\n\nReturns:\n    None\n""""""\ndef record(self, func: t.Callable) -> None:\n    """"""\n    Records a callable function to be executed later.\n\n    Args:\n        func (t.Callable): The function to be recorded.\n    """"""\n    self.deferred_functions.append(func)')","(True, '""""""\nRecords a function to be executed once during the first registration of a blueprint.\n\nThis method is used to register a function that should only be executed during the initial setup of a blueprint.\nThe function will be called when the blueprint\'s first registration occurs.\n\nArgs:\n    func (t.Callable): The function to be recorded and executed.\n\nReturns:\n    None\n""""""')","(True, '""""""\nWrapper function to handle first registration of users.\n\nThis function checks if the user has registered for the first time and calls the `func` function with the provided `state` object if so.\n\nArgs:\n    state (BlueprintSetupState): The current state of the application setup.\n\nReturns:\n    None\n""""""')","(True, '""""""\nCreates a new setup state for the given application.\n\nArgs:\n    - `app`: The Flask application instance.\n    - `options`: A dictionary of configuration options.\n    - `first_registration` (optional): Whether this is the first registration. Defaults to False.\n\nReturns:\n    A BlueprintSetupState object representing the created setup state.\n\nRaises:\n    None\n""""""')","(True, '""""""\nRegisters a blueprint with the current instance.\n\nArgs:\n    - blueprint (Blueprint): The blueprint to be registered.\n    - **options (t.Any): Optional keyword arguments for the blueprint registration.\n\nRaises:\n    ValueError: If the provided blueprint is the same as the current instance.\n\nReturns:\n    None\n""""""')","(False, 'def register(self, app: Flask, options: dict) -> None:\n    """"""\n    Registers the current Blueprint with the given Flask application.\n\n    This method checks for duplicate names and merges the Blueprint\'s data into the parent Blueprint.\n    It also sets up static file serving, error handling, view functions, and other settings as needed.\n\n    Args:\n        app (Flask): The Flask application to register the Blueprint with.\n        options (dict): A dictionary of options to pass to the Blueprint.\n\n    Raises:\n        ValueError: If a duplicate name is found for the current Blueprint.\n\n    Returns:\n        None\n    """"""')","(True, '""""""\nExtends a dictionary with another dictionary\'s values.\n\nThis function takes two dictionaries as input: `bp_dict` and `parent_dict`. It iterates over the items in `bp_dict`, \nconstructs new keys by appending the current key to the parent dictionary\'s name if it exists, and extends the \nvalues of the corresponding item in `parent_dict`.\n\nArgs:\n    bp_dict (dict): The dictionary containing values to be extended.\n    parent_dict (dict): The dictionary whose values will be extended.\n\nReturns:\n    None\n""""""')","(True, '""""""\nAdds a URL rule to the application.\n\nThis method is used to register a new route for the application. It takes in several parameters:\n\n- `rule`: The path of the URL rule.\n- `endpoint`: The name of the endpoint associated with this URL rule (optional).\n- `view_func`: The view function that will handle requests to this URL rule (optional).\n- `provide_automatic_options`: A boolean indicating whether to provide automatic options for this URL rule (optional).\n- `**options`: Any additional keyword arguments to pass to the `add_url_rule` method of the view function.\n\nIf either the `endpoint` or `view_func.__name__` contains a dot (\'.\'), a ValueError is raised. The `record` method is then called with a closure that adds this URL rule to the application.\n\nReturns:\n    None\n""""""')","(False, 'def app_template_filter(\n    """"""\n    A function that returns a decorator to add an application template filter.\n\n    Args:\n        name (str | None): The name of the template filter. Defaults to None.\n\n    Returns:\n        T.Callable[[T_template_filter], T_template_filter]: A decorator function.\n    """""")')","(False, '""""""\nAdds a template filter to the application.\n\nThis function takes a template filter as input and adds it to the application.\nThe added filter is then returned by this function.\n\nArgs:\n    f (T_template_filter): The template filter to be added.\n\nReturns:\n    T_template_filter: The original template filter with the added functionality.\n\nRaises:\n    None\n""""""\ndef decorator(f: T_template_filter) -> T_template_filter:\n    self.add_app_template_filter(f, name=name)\n    return f')","(True, '""""""\nAdds a template filter to the application\'s Jinja environment.\n\nThis function registers a new template filter with the given name, which can be used in templates to perform custom operations. If no name is provided, the filter will be registered under its original name (i.e., the name of the `f` function).\n\nArgs:\n    f: A callable that implements the template filter functionality.\n    name: The name under which the filter should be registered (optional). Defaults to None.\n\nReturns:\n    None\n""""""')","(True, '""""""\nRegisters a Jinja2 filter with the given application state.\n\nArgs:\n    state (BlueprintSetupState): The application state to modify.\n\nReturns:\n    None\n""""""')","(True, '""""""\nDecorates a function with the `app_template_test` metadata.\n\nThis decorator adds an application template test to the decorated function.\nIt takes an optional `name` parameter to specify the test name.\n\nArgs:\n    f (Callable): The function to be decorated.\n    name (str, optional): The name of the test. Defaults to None.\n\nReturns:\n    Callable: The decorated function with added metadata.\n""""""')","(True, '""""""\nDecorates a test function with an application template test.\n\nThis function takes a test function `f` as input and adds it to the list of \napplication template tests. The decorated function is then returned.\n\nArgs:\n    f (T_template_test): The test function to be decorated.\n\nReturns:\n    T_template_test: The decorated test function.\n""""""')","(True, '""""""\nAdds a template test to the application\'s Jinja environment.\n\nThis function registers a template test with the given name (defaulting to the test function\'s name if not provided).\n\nArgs:\n    f (ft.TemplateTestCallable): The test function to register.\n    name (str | None, optional): The name of the test. Defaults to None.\n\nReturns:\n    None\n""""""')","(True, '""""""\nRegisters a Jinja template test in the application\'s setup state.\n\nArgs:\n    state (BlueprintSetupState): The current state of the application\'s setup.\n\nReturns:\n    None\n""""""')","(True, '""""""\nDecorates a function to make it available as an application template global.\n\nThis decorator adds the decorated function to the list of application template globals.\nIt is typically used in conjunction with the `add_app_template_global` method.\n\nArgs:\n    name (str | None): The name under which the decorated function should be added. If None, no name will be specified.\n\nReturns:\n    T_template_global: A decorator function that adds the decorated function to the list of application template globals.\n""""""')","(True, '""""""\nDecorates a function to add it as an app template global.\n\nArgs:\n    f (T_template_global): The function to be decorated.\n\nReturns:\n    T_template_global: The decorated function.\n""""""')","(True, '""""""\nAdds a template global to the application.\n\nThis function registers a template global with the given name. If no name is provided, it defaults to the name of the provided callable.\n\nArgs:\n    f (ft.TemplateGlobalCallable): The callable to register as a template global.\n    name (str | None, optional): The name of the template global. Defaults to None.\n\nReturns:\n    None\n""""""')","(True, '""""""\nRegisters a template as a global variable in the Jinja environment.\n\nArgs:\n    state (BlueprintSetupState): The current setup state of the application.\n    \nReturns:\n    None\n    \nRaises:\n    TypeError: If `state` is not an instance of BlueprintSetupState.\n""""""')","(True, '""""""\nRecords a function to be executed before the application request.\n\nArgs:\n    f (T_before_request): The function to be recorded.\n\nReturns:\n    T_before_request: The input function with the record added.\n""""""')","(True, '""""""\nRecords a function as an \'after-app-request\' hook.\n\nArgs:\n    f (T_after_request): The function to be recorded.\n\nReturns:\n    T_after_request: The input function.\n""""""')","(True, '""""""\nRecords a teardown request function for the current application context.\n\nArgs:\n    f (T_teardown): The teardown request function to be recorded.\n\nReturns:\n    T_teardown: The original teardown request function.\n""""""')","(True, '""""""\nProcesses the template context for an application.\n\nThis function is used to add a new template context processor to the existing list.\nIt ensures that the processor is added only once by using the `record_once` method.\n\nArgs:\n    f (T_template_context_processor): The template context processor to be added.\n\nReturns:\n    T_template_context_processor: The original template context processor, which has been modified in-place.\n""""""')","(True, '""""""\nApp Error Handler Decorator.\n\nThis function returns a decorator that can be used to handle application errors.\nThe decorator takes an error handling function as input and wraps it with the provided app error handler.\n\nArgs:\n    code (type[Exception] | int): The type of exception or error code to use for error handling.\n    f (T_error_handler): The error handling function to wrap.\n\nReturns:\n    T_error_handler: The wrapped error handling function.\n\nExample:\n    @app_errorhandler(404)\n    def handle_404(f):\n        # Handle 404 errors\n        pass\n\n    @app_errorhandler(Exception)\n    def handle_all_errors(f):\n        # Handle all exceptions\n        pass\n""""""')","(True, '""""""\nDecorates a function with error handling.\n\nThis decorator records the first occurrence of an exception and uses it to update the application\'s error handler.\n\nArgs:\n    f (function): The function to be decorated.\n\nReturns:\n    function: The decorated function.\n""""""')","(True, '""""""\nPreprocesses the given URL value preprocessor and records it in the application\'s internal state.\n\nArgs:\n    f (T_url_value_preprocessor): The URL value preprocessor to be recorded.\n\nReturns:\n    T_url_value_preprocessor: The original preprocessor, which has been marked as recorded.\n""""""')","(True, '""""""\nReturns a URL default function and records it in the `url_default_functions` set.\n\nArgs:\n    f (T_url_defaults): The URL default function to be returned.\n\nReturns:\n    T_url_defaults: The provided URL default function.\n""""""')","(True, '""""""\nDecorates a method with setup functionality.\n\nThis decorator sets up the method by checking if the setup process is finished\nand updating the wrapper function to include the original method\'s metadata.\n\nArgs:\n    f (function): The method to be decorated.\n\nReturns:\n    function: The decorated method.\n""""""')","(True, '""""""\nWrapper function for a specific class method.\n\nThis function checks if the setup is finished before calling the original method.\nIt then calls the original method with the provided arguments and returns its result.\n\nArgs:\n    self: The instance of the class that owns this method.\n    *args: Variable number of positional arguments to be passed to the original method.\n    **kwargs: Variable number of keyword arguments to be passed to the original method.\n\nReturns:\n    The result of the original method call.\n\nRaises:\n    None\n""""""')","(True, '""""""\nInitialize a Flask application.\n\nThis function initializes a new instance of the Flask class. It takes several\nparameters that define the configuration and behavior of the application.\n\nParameters:\n    import_name (str): The name of the package or module that this object belongs to.\n    static_folder (str | os.PathLike | None, optional): The path to the static folder. Defaults to None.\n    static_url_path (str | None, optional): The URL path for static files. Defaults to None.\n    template_folder (str | os.PathLike | None, optional): The path to the templates folder. Defaults to None.\n    root_path (str | None, optional): The absolute path to the package on the filesystem. Defaults to None.\n\nAttributes:\n    import_name (str): The name of the package or module that this object belongs to.\n    static_folder (str | os.PathLike | None): The path to the static folder.\n    static_url_path (str | None): The URL path for static files.\n    template_folder (str | os.PathLike | None): The path to the templates folder.\n    root_path (str | None): The absolute path to the package on the filesystem.\n    cli (AppGroup): The Click command group for registering CLI commands.\n    view_functions (dict[str, t.Callable]): A dictionary mapping endpoint names to view functions.\n    error_handler_spec (dict[ft.AppOrBlueprintKey, dict[int | None, dict[type[Exception], ft.ErrorHandlerCallable]]]): A data structure of registered error handlers.\n    before_request_funcs (dict[ft.AppOrBlueprintKey, list[ft.BeforeRequestCallable]]): A data structure of functions to call at the beginning of each request.\n    after_request_funcs (dict[ft.AppOrBlueprintKey, list[ft.AfterRequestCallable]]): A data structure of functions to call at the end of each request.\n    teardown_request_funcs (dict[ft.AppOrBlueprintKey, list[ft.TeardownCallable]]): A data structure of functions to call to pass extra context values when rendering templates.\n    template_context_processors (dict[ft.AppOrBlueprintKey, list[ft.TemplateContextProcessorCallable]]): A data structure of functions to call to modify the keyword arguments passed to the view function.\n    url_value_preprocessors (dict[ft.AppOrBlueprintKey, list[ft.URLValuePreprocessorCallable]]): A data structure of functions to call to modify the keyword arguments when generating URLs.\n    url_default_functions (dict[ft.AppOrBlueprintKey, list[ft.URLDefaultCallable]]): A data structure of functions to call to modify the keyword arguments when generating URLs.\n\nRaises:\n    TypeError: If any parameter is not of the correct type.\n""""""')","(True, '""""""\nReturns a string representation of the object.\n\nThis method is used to provide a human-readable representation of the object, \nincluding its type and name. It is typically used for debugging purposes or \nwhen displaying objects in a user interface.\n\nArgs:\n    None\n\nReturns:\n    str: A string representation of the object.\n""""""')","(True, '""""""\nRaises a NotImplementedError when setup is not finished.\n\nThis method should be implemented by subclasses to check if the setup process is complete.\nIf the setup is not finished, it raises a NotImplementedError with an appropriate message.\n\nArgs:\n    f_name (str): The name of the file being checked.\n\nReturns:\n    None\n""""""')","(True, '""""""\nReturns the path to the static folder. If no static folder has been set, returns None.\n\nArgs:\n    None\n\nReturns:\n    str | None: The path to the static folder or None if not set.\n""""""')","(True, '""""""\nSets the path to a static folder.\n\nThis method takes a string or Path-like object representing the path to a static folder.\nIf the provided path is absolute, it will be normalized and any trailing slash removed.\nThe resulting path is then stored in the `_static_folder` attribute of the instance.\n\nArgs:\n    value (str | os.PathLike | None): The path to the static folder.\n\nReturns:\n    None\n""""""')","(True, '""""""\nReturns whether the object has a static folder.\n\nThis method checks if the `static_folder` attribute of the object is not None.\nIt can be used to determine if the object has a static folder available for serving files. \n\nArgs:\n    None\n\nReturns:\n    bool: True if the object has a static folder, False otherwise\n""""""')","(True, '""""""\nReturns the static URL path for this object.\n\nIf a precomputed URL path exists, it returns that. Otherwise, it constructs a URL path from the `static_folder` attribute by taking the basename of the folder and appending it to the root URL.\n\nReturns:\n    str | None: The static URL path or None if no valid path can be constructed.\n""""""')","(True, '""""""\nReturns a static URL path.\n\nThis method takes a string or None as input and returns the URL path after removing any trailing slashes. If the input is None, it sets the internal `_static_url_path` attribute to None.\n\nArgs:\n    value (str | None): The URL path to be processed.\n\nReturns:\n    None\n""""""')","(True, '""""""\nReturns the maximum age in seconds for sending files.\n\nIf `filename` is provided, it will be used to retrieve the default send file max age from the application configuration.\nOtherwise, the default value will be returned.\n\nArgs:\n    filename (str | None): The name of the file to use for retrieving the default send file max age. Defaults to None.\n\nReturns:\n    int | None: The maximum age in seconds for sending files, or None if no default is set.\n""""""')","(True, '""""""\nSends a static file from the configured static folder.\n\nThis method is used to serve static files. It checks if the `static_folder` attribute has been set and raises a RuntimeError if not.\nIt then calls `get_send_file_max_age` to determine the maximum age for the file, which is necessary for blueprints to work correctly.\nFinally, it uses `send_from_directory` to send the file from the static folder.\n\nArgs:\n    filename (str): The name of the file to be sent.\n\nReturns:\n    Response: A response object containing the sent file.\n\nRaises:\n    RuntimeError: If \'static_folder\' is not set.\n""""""')","(True, '""""""\nLoads a Jinja template loader based on the presence of a template folder.\n\nReturns:\n    FileSystemLoader: A Jinja template loader instance if a template folder is found.\n    None: No template folder found, returns None.\n""""""')","(True, '""""""\nOpens a resource file.\n\nArgs:\n    resource (str): The path to the resource file.\n    mode (str, optional): The mode in which to open the file. Defaults to ""rb"". Supported modes are ""r"", ""rt"", and ""rb"".\n\nReturns:\n    t.IO[t.AnyStr]: A file object opened in the specified mode.\n\nRaises:\n    ValueError: If an unsupported mode is provided.\n""""""')","(True, '""""""\nDetermine and apply a route method.\n\nThis function is used internally by the class to determine and apply a specific route method.\nIt takes in the method name, rule, and options as parameters. If the \'methods\' key exists in the options dictionary,\nit raises a TypeError indicating that the \'route\' decorator should be used instead.\n\nArgs:\n    self: The instance of the class.\n    method (str): The name of the route method to apply.\n    rule (str): The rule for which the method is applied.\n    options (dict): A dictionary containing additional options for the route.\n\nReturns:\n    t.Callable[[T_route], T_route]: A callable function that applies the specified route method to a given route object.\n\nRaises:\n    TypeError: If the \'methods\' key exists in the options dictionary, indicating that the \'route\' decorator should be used.\n""""""')","(True, '""""""\nReturns a callable function for handling HTTP GET requests.\n\nArgs:\n    rule (str): The route to be handled.\n    **options (t.Any): Additional keyword arguments to be passed to the method.\n\nReturns:\n    t.Callable[[T_route], T_route]: A callable function that handles HTTP GET requests.\n""""""')","(False, '""""""\nPost a route to the server.\n\nThis function is used to create or update a route on the server. It takes in a rule and optional parameters, then returns a callable that can be used to post data to the specified route.\n\nArgs:\n    rule (str): The rule for the route.\n    **options: t.Any: Optional parameters for the route.\n\nReturns:\n    t.Callable[[T_route], T_route]: A callable that can be used to post data to the specified route.')","(True, '""""""\nReturns a callable function for handling HTTP PUT requests.\n\nArgs:\n    rule (str): The route to be handled.\n    **options (t.Any): Additional keyword arguments to be passed to the underlying method.\n\nReturns:\n    t.Callable[[T_route], T_route]: A callable function that handles HTTP PUT requests for the given rule.\n""""""')","(True, '""""""\nDeletes a route.\n\nArgs:\n    rule (str): The path of the route to be deleted.\n    **options (t.Any): Additional keyword arguments for the method.\n\nReturns:\n    t.Callable[[T_route], T_route]: A callable function that deletes the specified route.\n\nRaises:\n    ValueError: If the rule is not a valid path.\n""""""')","(True, '""""""\nPatches a route with the specified rule and options.\n\nArgs:\n    rule (str): The rule to patch.\n    **options (t.Any): Additional options for the route.\n\nReturns:\n    t.Callable[[T_route], T_route]: A callable that patches the route.\n\nRaises:\n    None\n""""""')","(True, '""""""\nRoute a URL pattern to a view function.\n\nThis function is used to create a route for a given URL pattern. It takes in the rule of the URL and any additional options as keyword arguments. The `endpoint` option can be provided to specify an endpoint name, which will be used when adding the URL rule.\n\nThe returned decorator function can be applied to view functions to register them with this router.\n\nArgs:\n    rule (str): The URL pattern to route.\n    **options: t.Any: Additional options for the URL rule. Can include \'endpoint\' to specify an endpoint name.\n\nReturns:\n    T_route -> T_route: A decorator function that registers a view function with this router.\n""""""')","(True, '""""""\nDecorates a function to register it as an endpoint.\n\nThis decorator takes a function `f` and registers it with the Flask application.\nIt also populates the ""endpoint"" key in the options dictionary if present,\nand passes the remaining options to the `add_url_rule` method.\n\nArgs:\n    f (function): The function to be decorated.\n\nReturns:\n    function: The original function, now registered as an endpoint.\n""""""')","(False, '""""""\nAdds a URL rule to the application.\n\nThis method is used to register a new route for the application. It takes in several parameters:\n\n- `rule`: The URL pattern that will be matched by this rule.\n- `endpoint`: The view function that will handle requests to this URL (optional).\n- `view_func`: An alternative way to specify the endpoint (ft.RouteCallable type).\n- `provide_automatic_options`: Whether or not to provide automatic options for this route (bool type, default is None).\n- `**options`: Any additional keyword arguments that can be passed to the view function.\n\nThis method raises a NotImplementedError as it is currently not implemented.')","(True, '""""""\nEndpoint Decorator Function\n\nThis function is a decorator that registers an endpoint with the provided endpoint string.\nIt takes in a function `f` and returns a new function that wraps the original function, \nregistering it as a view function for the specified endpoint.\n\nArgs:\n    endpoint (str): The endpoint to register the function under.\n    f (Callable[[F], F]): The function to be registered as a view function.\n\nReturns:\n    Callable[[F], F]: A new function that wraps the original function and registers it as a view function.\n""""""')","(True, '""""""\nDecorates a view function with endpoint information.\n\nThis function is used to register and decorate view functions for use in the application.\nIt takes a view function `f` as an argument, adds it to the `view_functions` dictionary \nwith the current endpoint, and then returns the original function. This allows for easy\nmanagement of view functions and their corresponding endpoints.\n\nArgs:\n    f (F): The view function to be decorated.\n\nReturns:\n    F: The decorated view function.\n""""""')","(True, '""""""\nAdds a request handler function to the `before_request_funcs` set.\n\nArgs:\n    f (T_before_request): The request handler function to be added.\n\nReturns:\n    T_before_request: The original request handler function.\n""""""')","(True, '""""""\nAdds a request handler function to the `after_request_funcs` set.\n\nArgs:\n    f (T_after_request): The request handler function to be added.\n\nReturns:\n    T_after_request: The original request handler function.\n""""""')","(True, '""""""\nAdds a teardown request function to the internal list of teardown functions.\n\nArgs:\n    f (T_teardown): The teardown request function to be added.\n\nReturns:\n    T_teardown: The original teardown request function.\n""""""')","(True, '""""""\nProcesses a template context processor.\n\nThis function is used to register and manage template context processors.\nIt takes in a `f` parameter, which is the template context processor to be added,\nand returns the same `f` after adding it to the list of registered processors.\n\nArgs:\n    f (T_template_context_processor): The template context processor to be added.\n\nReturns:\n    T_template_context_processor: The original template context processor.\n""""""')","(True, '""""""\nPreprocesses a URL value by appending it to the list of preprocessed values.\n\nArgs:\n    f (T_url_value_preprocessor): The URL value to be preprocessed.\n\nReturns:\n    T_url_value_preprocessor: The preprocessed URL value.\n""""""')","(True, '""""""\nAdds a URL defaults function to the `url_default_functions` dictionary.\n\nArgs:\n    f (T_url_defaults): The URL defaults function to be added.\n\nReturns:\n    T_url_defaults: The provided URL defaults function, which is then appended to the `url_default_functions` dictionary.\n""""""')","(True, '""""""\nDecorates a function to handle specific exceptions.\n\nThis function returns a decorator that registers the provided function as an error handler for the specified exception type or code. The decorated function will be called when the registered exception is raised.\n\nArgs:\n    self: The instance of the class that this method belongs to.\n    code_or_exception (type[Exception] | int): The type of exception or code to register the decorator for.\n    f (T_error_handler): The function to decorate as an error handler.\n\nReturns:\n    T_error_handler: The decorated function.\n""""""')","(True, '""""""\nDecorates a function to register it as an error handler.\n\nThis decorator takes a function `f` that handles errors and registers it with the \n`register_error_handler` method. The decorated function is then returned.\n\nArgs:\n    f (T_error_handler): The function to be registered as an error handler.\n\nReturns:\n    T_error_handler: The decorated function.\n""""""')","(True, '""""""\nRegisters an error handler for a specific exception class or code.\n\nArgs:\n    - `self`: The instance of the class that this method belongs to.\n    - `code_or_exception`: A type hint indicating whether it\'s an exception class (type[Exception]) or an integer representing an HTTP status code. This parameter is used to determine which part of the error handler specification to update.\n    - `f`: An instance of ft.ErrorHandlerCallable, which represents a function that will be called when an error occurs.\n\nReturns:\n    None\n\nRaises:\n    None\n""""""')","(True, '""""""\nReturns the exception class and its corresponding code (if applicable) from a given exception class or code.\n\nArgs:\n    exc_class_or_code: The exception class or code to retrieve. Can be an instance of Exception or an integer representing an HTTP error code.\n\nReturns:\n    A tuple containing the exception class and its code (or None if not applicable).\nRaises:\n    ValueError: If the provided code is not a recognized HTTP error code.\n    TypeError: If the provided value is not an instance of Exception or an integer representing an HTTP error code, or if it\'s an instance of Exception instead of a class.\n""""""')","(False, 'def _endpoint_from_view_func(view_func: callable) -> str:\n    """"""\n    Extracts the endpoint name from a given view function.\n\n    Args:\n        view_func (callable): The view function to extract the endpoint from.\n\n    Returns:\n        str: The endpoint name of the provided view function.\n\n    Raises:\n        AssertionError: If no view function is provided.\n    """"""')","(False, '""""""\nChecks if a given path is relative to another base path.\n\nArgs:\n    path (pathlib.PurePath): The path to check.\n    base (str): The base path to compare against.\n\nReturns:\n    bool: True if the path is relative to the base, False otherwise.')","(False, '""""""\nFind the path to a Python package or module.\n\nThis function takes an import name as input and returns the path to the corresponding package or module.\nIf the package or module is not found, it raises a ValueError. If the import fails for any reason, it falls back to the current working directory.\n\nParameters:\n    import_name (str): The name of the package or module to find.\n\nReturns:\n    str: The path to the package or module.\n\nRaises:\n    ValueError: If the package or module is not found.\n""""""\n\ndef _find_package_path(import_name):\n    # ... (rest of the code remains the same)')","(True, '""""""\nFind the path to a Python package.\n\nThis function takes an import name as input and returns the prefix and full path of the corresponding package.\nIf the package is installed system-wide, it returns the prefix and full path. If the package is installed in a virtual environment,\nit returns the parent directory and full path. If the package is not installed, it returns None for both values.\n\nParameters:\n    import_name (str): The name of the Python package to find.\n\nReturns:\n    tuple: A tuple containing the prefix and full path of the package, or None if the package is not installed.\n""""""')"
"(True, '""""""\nAdds a static route to the application using the provided `static_url_path`, \n`static_host`, and `static_folder`. This is done without checking if \n`static_folder` exists, as it might be created while the server is running. \n\nThis method uses a weakref to avoid creating a reference cycle between the app \nand the view function.\n\nArgs:\n    - import_name (str): The name of the module being imported.\n    - static_url_path (str | None): The URL path for serving static files.\n    - static_folder (str | os.PathLike | None): The folder where static files are stored. Defaults to ""static"".\n    - static_host (str | None): The host for serving static files. Required if `host_matching` is False.\n    - host_matching (bool): Whether the host should be matched in the URL path. Defaults to False.\n    - subdomain_matching (bool): Whether the subdomain should be matched in the URL path. Defaults to False.\n    - template_folder (str | os.PathLike | None): The folder where templates are stored. Defaults to ""templates"".\n    - instance_path (str | None): The path for serving instance-specific files. Defaults to None.\n    - instance_relative_config (bool): Whether configuration should be relative to the instance. Defaults to False.\n    - root_path (str | None): The root path of the application. Defaults to None.\n\nRaises:\n    AssertionError: If `static_host` and `host_matching` do not match, or if `static_folder` exists but is not configured.\n""""""')","(True, '""""""\nReturns the maximum age in seconds for sending files.\n\nIf `filename` is provided, it will be used to retrieve the default send file max age from the application configuration.\nOtherwise, the default value will be returned.\n\nArgs:\n    filename (str | None): The name of the file to use for retrieving the default send file max age. Defaults to None.\n\nReturns:\n    int | None: The maximum age in seconds for sending files, or None if no default is set.\n""""""')","(True, '""""""\nSends a static file from the configured static folder.\n\nThis method is used to serve static files. It checks if the `static_folder` attribute has been set and raises a RuntimeError if not.\nIt then calls `get_send_file_max_age` to determine the maximum age for the file, which is necessary for blueprints to work correctly.\nFinally, it uses `send_from_directory` to send the file from the static folder.\n\nArgs:\n    filename (str): The name of the file to be sent.\n\nReturns:\n    Response: A response object containing the sent file.\n\nRaises:\n    RuntimeError: If \'static_folder\' is not set.\n""""""')","(True, '""""""\nOpens a resource file.\n\nArgs:\n    resource (str): The path to the resource file.\n    mode (str, optional): The mode in which to open the file. Defaults to ""rb"". Supported modes are ""r"", ""rt"", and ""rb"".\n\nReturns:\n    t.IO[t.AnyStr]: A file object opened in the specified mode.\n\nRaises:\n    ValueError: If an unsupported mode is provided.\n""""""')","(True, '""""""\nCreates a URL adapter for the current request.\n\nIf `subdomain_matching` is disabled, it uses the default subdomain.\nOtherwise, it does not use a subdomain. The server name and subdomain are\nprinted to the console for debugging purposes.\n\nReturns:\n    A bound URL map or None if the server name is not set.\n""""""')","(False, '""""""\nRaises a routing exception if the request is not debuggable, \nor if it\'s a redirect with an invalid status code or method.\n\nArgs:\n    request (Request): The incoming HTTP request.\n\nReturns:\n    None\n""""""\ndef raise_routing_exception(self, request: Request) -> t.NoReturn:\n    ...\n')","(True, '""""""\nHandles HTTP exceptions by checking their type and returning them accordingly.\n\nIf the exception does not have an error code (i.e., it\'s a ProxyException), \nit will be returned unchanged as an error. If it\'s a RoutingException, \nit will also be returned without modification. Otherwise, it will be \npassed to the error handler function to determine its response.\n\nArgs:\n    e (HTTPException): The HTTP exception to handle.\nReturns:\n    HTTPException | ft.ResponseReturnValue: The handled exception or its response.\n""""""')","(True, '""""""\nHandles exceptions raised by the application.\n\nThis function checks for specific exception types and decides how to handle them.\nIf a `BadRequestKeyError` occurs and debug mode or the trap bad request errors config flag are set, it sets the `show_exception` attribute of the error object to True.\nIf an `HTTPException` occurs but is not trapped by the application, it calls the `handle_http_exception` method to handle the exception.\nOtherwise, it finds an error handler for the exception using the `_find_error_handler` method and calls it with the exception as an argument.\n\nArgs:\n    e (Exception): The exception to be handled.\nReturns:\n    HTTPException | ft.ResponseReturnValue: The result of handling the exception or None if no handler is found.\n""""""')","(True, '""""""\nHandles exceptions raised during the execution of a request.\n\nIf propagation is enabled, re-raises the exception. Otherwise, logs the exception and\ncontinues with the next error handler in the chain.\n\nArgs:\n    e (Exception): The exception to be handled.\n\nReturns:\n    Response: A response object containing the server error.\n""""""')","(True, '""""""\nReturns the maximum age in seconds for sending files.\n\nIf `filename` is provided, it will be used to retrieve the default send file max age from the application configuration.\nOtherwise, the default value will be returned.\n\nArgs:\n    filename (str | None): The name of the file to use for retrieving the default send file max age. Defaults to None.\n\nReturns:\n    int | None: The maximum age in seconds for sending files, or None if no default is set.\n""""""')","(True, '""""""\nSends a static file from the configured static folder.\n\nThis method is used to serve static files. It checks if the `static_folder` attribute has been set and raises a RuntimeError if not.\nIt then calls `get_send_file_max_age` to determine the maximum age for the file, which is necessary for blueprints to work correctly.\nFinally, it uses `send_from_directory` to send the file from the static folder.\n\nArgs:\n    filename (str): The name of the file to be sent.\n\nReturns:\n    Response: A response object containing the sent file.\n\nRaises:\n    RuntimeError: If \'static_folder\' is not set.\n""""""')","(True, '""""""\nOpens a resource file.\n\nArgs:\n    resource (str): The path to the resource file.\n    mode (str, optional): The mode in which to open the file. Defaults to ""rb"". Supported modes are ""r"", ""rt"", and ""rb"".\n\nReturns:\n    t.IO[t.AnyStr]: A file object opened in the specified mode.\n\nRaises:\n    ValueError: If an unsupported mode is provided.\n""""""')","(False, 'def explain_template_loading_attempts(app: App, template, attempts) -> None:\n    """"""\n    Logs information about template loading attempts.\n\n    This function takes an application object, a template name, and a list of\n    loader attempts. It iterates over the loaders, logging information about each\n    attempt, including any matches found or errors encountered. If no matches are\n    found, it logs an error message. If multiple matches are found, it logs a\n    warning message.\n\n    Args:\n        app (App): The application object.\n        template (str): The name of the template to load.\n        attempts (list[tuple[loader, srcobj, triple]]): A list of loader attempts,\n            where each attempt is a tuple containing the loader, source object,\n            and any match found.\n\n    Returns:\n        None\n    """"""\n    info = [f""Locating template {template!r}:""]\n    total_found = 0\n    blueprint = None\n    if request_ctx and request_ctx.request.blueprint is not None:\n        blueprint = request_ctx.request.blueprint\n\n    for idx, (loader, srcobj, triple) in enumerate(attempts):\n        if isinstance(srcobj, App):\n            src_info = f""application {srcobj.import_name!r}""\n        elif isinstance(srcobj, Blueprint):\n            src_info = f""blueprint {srcobj.name!r} ({srcobj.import_name})""\n        else:\n            src_info = repr(srcobj)\n\n        info.append(f""{idx + 1:5}: trying loader of {src_info}"")\n\n        for line in _dump_loader_info(loader):\n            info.append(f""       {line}"")\n\n        if triple is None:\n            detail = ""no match""\n        else:\n            detail = f""found ({triple[1] or \'<string>\'!r})""\n            total_found += 1\n        info.append(f""       -> {detail}"")\n\n    seems_fishy = False\n    if total_found == 0:\n        info.append(""Error: the template could not be found."")\n        seems_fishy = True\n    elif total_found > 1:\n        info.append(""Warning: multiple loaders returned a match for the template."")\n        seems_fishy = True\n\n    if blueprint is not None and seems_fishy:\n        info.append(\n            ""  The template was looked up from an endpoint that belongs""\n            f"" to the blueprint {blueprint!r}.""\n        )\n        info.append(""  Maybe you did not place a template in the right folder?"")\n        info.append(""  See https://flask.palletsprojects.com/blueprints/#templates"")\n\n    app.logger.info(""\\n"".join(info))')","(True, '""""""\nInitializes the object with the given application instance.\n\nArgs:\n    app (App): The application instance to be used by this object.\n\nReturns:\n    None\n""""""')","(True, '""""""\nCreates a logger instance for the given application.\n\nArgs:\n    app (App): The application object containing the name of the logger.\n\nReturns:\n    logging.Logger: A configured logger instance.\n""""""')","(False, '""""""\nInitialize a new Flask application instance.\n\nThis function is used to create a new Flask application. It takes several parameters that can be used to customize the behavior of the application.\n\nParameters:\n    import_name (str): The name of the module where the application\'s configuration and other settings are defined.\n    static_url_path (str | None): The URL path for serving static files. Defaults to None.\n    static_folder (str | os.PathLike | None): The folder where static files are stored. Defaults to ""static"".\n    static_host (str | None): The host on which static files will be served. Defaults to None.\n    host_matching (bool): Whether the application should match hosts in its routing. Defaults to False.\n    subdomain_matching (bool): Whether the application should match subdomains in its routing. Defaults to False.\n    template_folder (str | os.PathLike | None): The folder where templates are stored. Defaults to ""templates"".\n    instance_path (str | None): The path to the instance folder. If not provided, it will be automatically determined by the `auto_find_instance_path` method. Raises ValueError if a relative path is given.\n    instance_relative_config (bool): Whether the application\'s configuration should be loaded from files in the instance folder. Defaults to False.\n    root_path (str | None): The root path of the application. Defaults to None.\n\nReturns:\n    None\n""""""\ndef __init__(\n        self,\n        import_name: str,\n        static_url_path: str | None = None,\n        static_folder: str | os.PathLike | None = ""static"",\n        static_host: str | None = None,\n        host_matching: bool = False,\n        subdomain_matching: bool = False,\n        template_folder: str | os.PathLike | None = ""templates"",\n        instance_path: str | None = None,\n        instance_relative_config: bool = False,\n        root_path: str | None = None,\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n        elif not os.path.isabs(instance_path):\n            raise ValueError(\n                ""If an instance path is provided it must be absolute.""\n                "" A relative path was given instead.""\n            )\n\n        #: Holds the path to the instance folder.\n        #:\n        #: .. versionadded:: 0.8\n        self.instance_path = instance_path\n\n        #: The configuration dictionary as :class:`Config`.  This behaves\n        #: exactly like a regular dictionary but supports additional methods\n        #: to load a config from files.\n        self.config = self.make_config(instance_relative_config)\n\n        #: An instance of :attr:`aborter_class` created by\n        #: :meth:`make_aborter`. This is called by :func:`flask.abort`\n        #: to raise HTTP errors, and can be called directly as well.\n        #:\n        #: .. versionadded:: 2.2\n        #:     Moved from ``flask.abort``, which calls this object.\n        self.aborter = self.make_aborter()\n\n        self.json: JSONProvider = self.json_provider_class(self)\n        """"""Provides access to JSON methods. Functions in ``flask.json``\n        will call methods on this provider when the application context\n        is active. Used for handling JSON requests and responses.\n\n        An instance of :attr:`json_provider_class`. Can be customized by\n        changing that attribute on a subclass, or by assigning to this\n        attribute afterwards.\n\n        The default, :class:`~flask.json.provider.DefaultJSONProvider`,\n        uses Python\'s built-in :mod:`json` library. A different provider\n        can use a different JSON library.\n\n        .. versionadded:: 2.2\n        """"""\n\n        #: A list of functions that are called by\n        #: :meth:`handle_url_build_error` when :meth:`.url_for` raises a\n        #: :exc:`~werkzeug.routing.BuildError`. Each function is called\n        #: with ``error``, ``endpoint`` and ``values``. If a function\n        #: returns ``None`` or raises a ``BuildError``, it is skipped.\n        #: Otherwise, its return value is returned by ``url_for``.\n        #:\n        #: .. versionadded:: 0.9\n        self.url_build_error_handlers: list[\n            t.Callable[[Exception, str, dict[str, t.Any]], str]\n        ] = []\n\n        #: A list of functions that are called when the application context\n        #: is destroyed.  Since the application context is also torn down\n        #: if the request ends this is the place to store code that disconnects\n        #: from databases.\n        #:\n        #: .. versionadded:: 0.9\n        self.teardown_appcontext_funcs: list[ft.TeardownCallable] = []\n\n        #: A list of shell context processor functions that should be run\n        #: when a shell context is created.\n        #:\n        #: .. versionadded:: 0.11\n        self.shell_context_processors: list[ft.ShellContextProcessorCallable] = []\n\n        #: Maps registered blueprint names to blueprint objects. The\n        #: dict retains the order the blueprints were registered in.\n        #: Blueprints can be registered multiple times, this dict does\n        #: not track how often they were attached.\n        #:\n        #: .. versionadded:: 0.7\n        self.blueprints: dict[str, Blueprint] = {}\n\n        #: a place where extensions can store application specific state.  For\n        #: example this is where an extension could store database engines and\n        #: similar things.\n        #:\n        #: The key must match the name of the extension module. For example in\n        #: case of a ""Flask-Foo"" extension in `flask_foo`, the key would be\n        #: ``\'foo\'``.\n        #:\n        #: .. versionadded:: 0.7\n        self.extensions: dict = {}\n\n        #: The :class:`~werkzeug.routing.Map` for this instance.  You can use\n        #: this to change the routing converters after the class was created\n        #: but before any routes are connected.  Example::\n        #:\n        #:    from werkzeug.routing import BaseConverter\n        #:\n        #:    class ListConverter(BaseConverter):\n        #:        def to_python(self, value):\n        #:            return value.split(\',\')\n        #:        def to_url(self, values):\n        #:            return \',\'.join(super(ListConverter, self).to_url(value)\n        #:                            for value in values)\n        #:\n        #:    app = Flask(__name__)\n        #:    app.url_map.converters[\'list\'] = ListConverter\n        self.url_map = self.url_map_class(host_matching=host_matching)\n\n        self.subdomain_matching = subdomain_matching\n\n        # tracks internally if the application already handled at least one\n        # request.\n        self._got_first_request = False\n\n        # Set the name of the Click group in case someone wants to add\n        # the app\'s commands to another CLI tool.\n        self.cli.name = self.name')","(True, '""""""\nRaises a NotImplementedError to be implemented by subclasses.\n\nSubclasses must provide an implementation of this method that returns a Jinja2 environment.\n""""""')","(True, '""""""\nTemplate Test Decorator.\n\nThis function returns a decorator that can be used to wrap a template test function.\nThe wrapped function will have its `name` attribute set by the `template_test` function.\n\nArgs:\n    f (Callable[[T_template_test], T_template_test]): The function to be decorated.\n    name (str | None, optional): The name of the template test. Defaults to None.\n\nReturns:\n    Callable[[T_template_test], T_template_test]: The decorated function.\n""""""')","(False, '""""""\nDecorates a test function with template testing.\n\nThis function takes a test function `f` as input and adds it to the template tests.\nThe decorated function is then returned.\n\nArgs:\n    f (T_template_test): The test function to be decorated.\n\nReturns:\n    T_template_test: The decorated test function.\n\nRaises:\n    None\n""""""\ndef decorator(f: T_template_test) -> T_template_test:\n    self.add_template_test(f, name=name)\n    return f')","(False, '""""""\nTemplate Global Decorator\n\nThis function is used to create a template global decorator. It takes a function `f` as an argument and returns the same function wrapped with the `add_template_global` method.\n\nThe `name` parameter can be provided to specify the name of the template global. If not specified, it defaults to None.\n\nArgs:\n    f (T_template_global): The function to be decorated.\n    name (str | None, optional): The name of the template global. Defaults to None.\n\nReturns:\n    T_template_global: The decorated function.\n""""""\ndef decorator(f: T_template_global) -> T_template_global:\n    """"""\nDecorates a function to add it as a template global.\n\nArgs:\n    f (T_template_global): The function to be decorated.\n\nReturns:\n    T_template_global: The decorated function.\n""""""\n    self.add_template_global(f, name=name)\n    return f')","(True, '""""""\nAdds a function as a template global.\n\nDecorates a function to make it accessible as a template global variable.\n\nArgs:\n    f (T_template_global): The function to be decorated. This should be a callable object.\n\nReturns:\n    T_template_global: The decorated function, which is now accessible as a template global variable.\n""""""')","(False, '""""""\nFinds the error handler for a given exception.\n\nThis function iterates through the blueprint handlers and class-specific handlers to find a matching error handler.\nIf no match is found, it returns `None`.\n\nArgs:\n    e (Exception): The exception for which to find an error handler.\n\nReturns:\n    ft.ErrorHandlerCallable | None: The error handler for the given exception, or `None` if no match is found.')","(True, '""""""\nDetermines whether an exception should be ignored.\n\nArgs:\n    error (BaseException | None): The exception to check. Can be None for no exception.\nReturns:\n    bool: True if the exception should be ignored, False otherwise.\n""""""')","(False, 'def redirect(self, location: str, code: int = 302) -> BaseResponse:\n    """"""\n    Redirects to a specified URL with an optional HTTP status code.\n\n    Args:\n        location (str): The URL to redirect to.\n        code (int, optional): The HTTP status code. Defaults to 302.\n\n    Returns:\n        BaseResponse: A response object containing the redirect URL and status code.\n    """"""\n    return _wz_redirect(\n        location, code=code, Response=self.response_class  # type: ignore[arg-type]\n    )')","(False, 'def __init__(\n    """"""\n    Initializes a new instance of the BlueprintSetupState class.\n\n    Args:\n        blueprint: A reference to the blueprint that created this setup state.\n        app: A reference to the current application.\n        options: A dictionary with all options that were passed to the\n            :meth:`~flask.Flask.register_blueprint` method.\n        first_registration: As blueprints can be registered multiple times with\n            the application and not everything wants to be registered multiple\n            times on it, this attribute can be used to figure out if the blueprint\n            was registered in the past already.\n\n    Returns:\n        None\n    """"""\n    self.app = app\n    self.blueprint = blueprint\n    self.options = options\n    self.first_registration = first_registration\n\n    subdomain = self.options.get(""subdomain"")\n    if subdomain is None:\n        subdomain = self.blueprint.subdomain\n\n    self.subdomain = subdomain\n\n    url_prefix = self.options.get(""url_prefix"")\n    if url_prefix is None:\n        url_prefix = self.blueprint.url_prefix\n\n    self.url_prefix = url_prefix\n\n    self.name = self.options.get(""name"", blueprint.name)\n    self.name_prefix = self.options.get(""name_prefix"", """")\n\n    self.url_defaults = dict(self.blueprint.url_values_defaults)\n    self.url_defaults.update(self.options.get(""url_defaults"", ()))')","(False, 'def record_once(func: t.Callable) -> None:\n    """"""\n    Records a function to be executed once during the first registration of a blueprint.\n\n    This method is used to register a function that should only be executed during the initial setup of a blueprint.\n    The function will be called when the blueprint\'s first registration occurs.\n\n    Args:\n        func (t.Callable): The function to be recorded and executed.\n\n    Returns:\n        None\n    """"""')","(True, '""""""\nWrapper function to handle first registration of users.\n\nThis function checks if the user has registered for the first time and calls the `func` function with the provided `state` object if so.\n\nArgs:\n    state (BlueprintSetupState): The current state of the application setup.\n\nReturns:\n    None\n""""""')","(False, '""""""\nCreates a new setup state for the given application.\n\nArgs:\n    - `app`: The Flask application instance.\n    - `options`: A dictionary of configuration options.\n    - `first_registration` (optional): Whether this is the first registration. Defaults to False.\n\nReturns:\n    A BlueprintSetupState object representing the created setup state.\n\nRaises:\n    None\n""""""\ndef make_setup_state(self, app: App, options: dict, first_registration: bool = False) -> BlueprintSetupState:\n    """"""\n    Creates a new setup state for the given application.\n\n    Args:\n        - `app`: The Flask application instance.\n        - `options`: A dictionary of configuration options.\n        - `first_registration` (optional): Whether this is the first registration. Defaults to False.\n\n    Returns:\n        A BlueprintSetupState object representing the created setup state.\n\n    Raises:\n        None\n    """"""\n    return BlueprintSetupState(self, app, options, first_registration)')","(False, '""""""\nRegisters the current class instance as a Blueprint in the provided Flask application.\n\nThis method checks for duplicate names and ensures that all necessary configuration is set up before registering the Blueprint.\nIt also merges the Blueprint\'s data with its parent\'s data if it\'s the first registration or has a unique name.\n\nArgs:\n    app (App): The Flask application to register the Blueprint in.\n    options (dict): A dictionary of options for the Blueprint, including \'name_prefix\' and \'name\'.\n\nReturns:\n    None\n""""""\ndef register(self, app: App, options: dict) -> None:')","(False, ""```\n## add_app_template_filter\n\nAdds a template filter to the application's Jinja environment.\n\n### Parameters\n\n* `f`: A callable that implements the template filter functionality.\n* `name`: The name under which the filter should be registered (optional). Defaults to None.\n\n### Returns\n\nNone\n```"")","(True, '""""""\nRegisters a Jinja2 filter with the given application state.\n\nArgs:\n    state (BlueprintSetupState): The application state to modify.\n\nReturns:\n    None\n""""""')","(False, '""""""\nDecorates a function with the `app_template_test` metadata.\n\nThis decorator adds an application template test to the decorated function.\nIt takes an optional `name` parameter to specify the test name.\n\nArgs:\n    f (Callable): The function to be decorated.\n    name (str, optional): The name of the test. Defaults to None.\n\nReturns:\n    Callable: The decorated function with added metadata.\n""""""\ndef app_template_test(self, name: str | None = None) -> t.Callable[[T_template_test], T_template_test]:\n    """"""\n    Decorates a test function with an application template test.\n\n    This function takes a test function `f` as input and adds it to the list of \n    application template tests. The decorated function is then returned.\n\n    Args:\n        f (T_template_test): The test function to be decorated.\n    \n    Returns:\n        T_template_test: The decorated test function.\n    """"""\n    def decorator(f: T_template_test) -> T_template_test:\n        """"""\n        Adds an application template test to the decorated function.\n\n        Args:\n            f (T_template_test): The test function to be decorated.\n\n        Returns:\n            T_template_test: The decorated test function.\n        """"""\n        self.add_app_template_test(f, name=name)\n        return f\n\n    return decorator')","(False, '""""""\nDecorates a test function with an application template test.\n\nThis function takes a test function `f` as input and adds it to the list of \napplication template tests. The decorated function is then returned.\n\nArgs:\n    f (T_template_test): The test function to be decorated.\n\nReturns:\n    T_template_test: The decorated test function.\n""""""\ndef decorator(f: T_template_test) -> T_template_test:\n    """"""\n    Adds a test function to the list of application template tests and returns the decorated function.\n\n    Args:\n        f (T_template_test): The test function to be added to the list of application template tests.\n\n    Returns:\n        T_template_test: The decorated test function.\n    """"""\n    self.add_app_template_test(f, name=name)\n    return f')","(False, ""```\n## add_app_template_test\n\nAdds a template test to the application's Jinja environment.\n\n### Parameters\n\n*   `f`: The test function to register.\n*   `name` (optional): The name of the test. Defaults to None, which uses the test function's name if not provided.\n\n### Returns\n\nNone\n```"")","(True, '""""""\nRegisters a Jinja template test in the application\'s setup state.\n\nArgs:\n    state (BlueprintSetupState): The current state of the application\'s setup.\n    \nReturns:\n    None: This function does not return any value. It modifies the provided BlueprintSetupState object directly.\n""""""')","(False, 'def app_template_global(\n    """"""\n    Decorates a function to make it available as an application template global.\n\n    This decorator adds the decorated function to the list of application template globals.\n    It is typically used in conjunction with the `add_app_template_global` method.\n\n    Args:\n        name (str | None): The name under which the decorated function should be added. If None, no name will be specified.\n\n    Returns:\n        T_template_global: A decorator function that adds the decorated function to the list of application template globals.\n    """"""\n) -> t.Callable[[T_template_global], T_template_global]:\n\n    def decorator(\n        """"""\n        Decorates a function to add it as an app template global.\n\n        Args:\n            f (T_template_global): The function to be decorated.\n\n        Returns:\n            T_template_global: The decorated function.\n        """"""\n    ) -> T_template_global:\n        self.add_app_template_global(f, name=name)\n        return f\n\n    return decorator')","(True, '""""""\nAdds the provided function as a template global for the application.\n\nArgs:\n    f (T_template_global): The function to be added as a template global.\n\nReturns:\n    T_template_global: The decorated function.\n""""""')","(False, '```\n## add_app_template_global\nAdds a template global to the application.\n\n### Parameters\n\n*   `f`: The callable to register as a template global.\n*   `name` (optional): The name of the template global. Defaults to None.\n\n### Returns\n\nNone\n\n### Raises\n\nTypeError: If `state` is not an instance of BlueprintSetupState.\n```')","(False, '""""""\nRegisters a template as a global variable in the Jinja environment.\n\nArgs:\n    state (BlueprintSetupState): The current setup state of the application.\n\nReturns:\n    None\n\nRaises:\n    TypeError: If `state` is not an instance of BlueprintSetupState.')","(False, '""""""\nApp Error Handler Decorator.\n\nThis function returns a decorator that can be used to handle application errors.\nThe decorator takes an error handling function as input and wraps it with the provided app error handler.\n\nArgs:\n    code (type[Exception] | int): The type of exception or error code to use for error handling.\n    f (T_error_handler): The error handling function to wrap.\n\nReturns:\n    T_error_handler: The wrapped error handling function.\n\nExample:\n    @app_errorhandler(404)\n    def handle_404(f):\n        # Handle 404 errors\n        pass\n\n    @app_errorhandler(Exception)\n    def handle_all_errors(f):\n        # Handle all exceptions\n        pass\n""""""\n \ndef decorator(f: T_error_handler) -> T_error_handler:\n    """"""\nDecorates a function with error handling.\n\nThis decorator records the first occurrence of an exception and uses it to update the application\'s error handler.\n\nArgs:\n    f (function): The function to be decorated.\n\nReturns:\n    function: The decorated function.\n""""""\n            self.record_once(lambda s: s.app.errorhandler(code)(f))\n            return f')","(True, '""""""\nDecorates a function with error handling.\n\nThis decorator records the first occurrence of an exception and uses it to update the application\'s error handler.\n\nArgs:\n    f (function): The function to be decorated.\n\nReturns:\n    function: The decorated function.\n""""""')","(False, '""""""\nRoute a URL pattern to a view function.\n\nThis function is used to create a route for a given URL pattern. It takes in the rule of the URL and any additional options as keyword arguments. The `endpoint` option can be provided to specify an endpoint name, which will be used when adding the URL rule.\n\nThe returned decorator function can be applied to view functions to register them with this router.\n\nArgs:\n    rule (str): The URL pattern to route.\n    **options: t.Any: Additional options for the URL rule. Can include \'endpoint\' to specify an endpoint name.\n\nReturns:\n    T_route -> T_route: A decorator function that registers a view function with this router.\n""""""\ndef route(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n    """"""\n    Decorates a function to register it as an endpoint.\n\n    This decorator takes a function `f` and registers it with the Flask application.\n    It also populates the ""endpoint"" key in the options dictionary if present,\n    and passes the remaining options to the `add_url_rule` method.\n\n    Args:\n        f (function): The function to be decorated.\n\n    Returns:\n        function: The original function, now registered as an endpoint.\n    """"""\n    def decorator(f: T_route) -> T_route:\n        endpoint = options.pop(""endpoint"", None)\n        self.add_url_rule(rule, endpoint, f, **options)\n        return f\n\n    return decorator')","(False, '""""""\nDecorates a function to register it as an endpoint.\n\nThis decorator takes a function `f` and registers it with the Flask application.\nIt also populates the ""endpoint"" key in the options dictionary if present,\nand passes the remaining options to the `add_url_rule` method.\n\nArgs:\n    f (function): The function to be decorated.\n\nReturns:\n    function: The original function, now registered as an endpoint.')","(False, '# Endpoint Decorator Function\n\n## Overview\n\nThis function is a decorator that registers an endpoint with the provided endpoint string.\nIt takes in a function `f` and returns a new function that wraps the original function, \nregistering it as a view function for the specified endpoint.\n\n## Parameters\n\n### endpoint (str)\n\nThe endpoint to register the function under.\n\n### f (Callable[[F], F])\n\nThe function to be registered as a view function.\n\n## Returns\n\nA new function that wraps the original function and registers it as a view function.')","(True, '""""""\nDecorates a view function with endpoint information.\n\nThis function is used to register and decorate view functions for use in the application.\nIt takes a view function `f` as an argument, adds it to the `view_functions` dictionary \nwith the current endpoint, and then returns the original function. This allows for easy\nmanagement of view functions and their corresponding endpoints.\n\nArgs:\n    f (F): The view function to be decorated.\n\nReturns:\n    F: The decorated view function.\n""""""')","(False, '""""""\nDecorates a function to handle specific exceptions.\n\nThis function returns a decorator that registers the provided function as an error handler for the specified exception type or code. The decorated function will be called when the registered exception is raised.\n\nArgs:\n    self: The instance of the class that this method belongs to.\n    code_or_exception (type[Exception] | int): The type of exception or code to register the decorator for.\n    f (T_error_handler): The function to decorate as an error handler.\n\nReturns:\n    T_error_handler: The decorated function.\n""""""\ndef errorhandler(\n        self, \n        code_or_exception: type[Exception] | int\n    ) -> t.Callable[[T_error_handler], T_error_handler]:\n    """"""\n    Decorates a function to register it as an error handler.\n\n    This decorator takes a function `f` that handles errors and registers it with the \n    `register_error_handler` method. The decorated function is then returned.\n\n    Args:\n        f (T_error_handler): The function to be registered as an error handler.\n\n    Returns:\n        T_error_handler: The decorated function.\n    """"""\n    def decorator(f: T_error_handler) -> T_error_handler:\n        self.register_error_handler(code_or_exception, f)\n        return f\n\n    return decorator')","(False, '""""""\nDecorates a function to register it as an error handler.\n\nThis decorator takes a function `f` that handles errors and registers it with the \n`register_error_handler` method. The decorated function is then returned.\n\nArgs:\n    f (T_error_handler): The function to be registered as an error handler.\n\nReturns:\n    T_error_handler: The decorated function.\n""""""\ndef decorator(f: T_error_handler) -> T_error_handler:\n    """"""\n    Registers a function as an error handler and returns the decorated function.\n\n    Args:\n        f (T_error_handler): The function to be registered as an error handler.\n\n    Returns:\n        T_error_handler: The decorated function.\n    """"""\n    self.register_error_handler(code_or_exception, f)\n    return f')","(False, '""""""\nInitialize a new Jinja2 environment.\n\nThis method is called when an instance of the class is created. It sets up the environment with the provided application and options.\n\nArgs:\n    app (App): The application instance.\n    **options (t.Any): Keyword arguments to customize the environment.\n\nReturns:\n    None\n""""""\n\ndef __init__(self, app: App, **options: t.Any) -> None:\nif ""loader"" not in options:\n    options[""loader""] = app.create_global_jinja_loader()\nBaseEnvironment.__init__(self, **options)\nself.app = app')","(True, '""""""\nInitializes the object with an application instance.\n\nArgs:\n    app (App): The application instance to be associated with this object.\n\nReturns:\n    None\n""""""')"
"(False, 'def register(self, app: App, options: dict) -> None:\n    """"""\n    Registers the current class instance with the given Flask application.\n\n    This method checks if a blueprint with the same name already exists and raises an error if it does.\n    It then sets up the necessary state for the instance and registers any deferred functions.\n    Finally, it adds the instance\'s commands to the application\'s CLI and registers any blueprints.\n\n    Args:\n        app (App): The Flask application to register the instance with.\n        options (dict): A dictionary of options to use when registering the instance.\n\n    Raises:\n        ValueError: If a blueprint with the same name already exists.\n\n    Returns:\n        None\n    """"""')","(True, '""""""\nMerges blueprint functions into the application\'s configuration.\n\nThis function merges the provided blueprint functions (`bp_dict`) with the parent dictionary\n(`parent_dict`) in a way that preserves the namespace. It also updates the application\'s error\nhandler specification and view functions accordingly.\n\nParameters:\napp (App): The application instance to be updated.\nname (str): The name of the blueprint, used for namespace resolution.\n\nReturns:\nNone\n""""""')","(True, '""""""\nExtends a dictionary with another dictionary\'s values.\n\nThis function takes two dictionaries as input: `bp_dict` and `parent_dict`. It iterates over the items in `bp_dict`, \nconstructs new keys by appending the current key to the parent dictionary\'s name if it exists, \nand extends the corresponding value in `parent_dict`.\n\nArgs:\n    bp_dict (dict): The dictionary containing values to be extended.\n    parent_dict (dict): The dictionary into which values will be extended.\n\nReturns:\n    None\n""""""')"
"(True, '""""""\nUpdates the template context with additional information.\n\nThis function is used to extend the context passed to a template, allowing it\nto be rendered outside of a request context. It iterates over the list of\ntemplate context processors and applies their functions to the current\ncontext, updating it accordingly.\n\nArgs:\n    context (dict): The initial context to update.\n\nReturns:\n    None\n""""""')"





"(True, '""""""\nReturns the version information of Python, Flask, and Werkzeug.\n\nParameters:\n- ctx (object): The context object containing information about the current session.\n- param (object): An optional parameter to be used in the function. Currently unused.\n- value (str): The input string that triggers this function call.\n\nReturns:\nNone\n\nSide Effects:\n- Prints the version information of Python, Flask, and Werkzeug to the console.\n- Exits the current session using ctx.exit().\n""""""')","(True, '""""""\nReturns the version of Werkzeug, a Python web framework.\n\nThis function uses the `importlib.metadata` module to retrieve the version from PyPI.\nIf the version is not already cached in `_werkzeug_version`, it will be retrieved and stored for future use.\n\nArgs:\n    None\n\nReturns:\n    str: The version of Werkzeug as a string\n""""""')","(False, '""""""\nInitialize the documentation assistant.\n\nThis function initializes a new instance of the documentation assistant, \nsetting default values for its attributes and calling the parent class\'s constructor.\n\nArgs:\n    *args: Variable length argument list containing any additional arguments.\n    **kwargs: Keyworded arguments containing any additional keyword arguments.\n\nReturns:\n    None\n""""""\ndef __init__(self, *args: t.Any, **kwargs: t.Any) -> None:\n    super().__init__(*args, **kwargs)\n    self.preserve_context = False\n    self._new_contexts: list[t.ContextManager[t.Any]] = []\n    self._context_stack = ExitStack()\n    self.environ_base = {\n        ""REMOTE_ADDR"": ""127.0.0.1"",\n        ""HTTP_USER_AGENT"": f""Werkzeug/{_get_werkzeug_version()}"",\n    }')","(False, '""""""\nTests the functionality of the `test_get_version` function.\n\nThis test verifies that the function correctly retrieves and prints the versions of Python, Flask, and Werkzeug when called with a mock context object.\n\nParameters:\n    test_apps (list): A list of application names to use for testing.\n    capsys (unittest.mock.Mock): A mock object used to capture the output of the `get_version` function.\n\nReturns:\n    None\n""""""\ndef test_get_version(test_apps, capsys):\n    class MockCtx:\n        """"""A mock context object used to simulate a Flask application.""""""\n        resilient_parsing = False\n        color = None\n\n        def exit(self):\n            return\n\n    ctx = MockCtx()\n    get_version(ctx, None, ""test"")\n    out, err = capsys.readouterr()\n    assert f""Python {platform.python_version()}"" in out\n    assert f""Flask {importlib.metadata.version(\'flask\')}"" in out\n    assert f""Werkzeug {importlib.metadata.version(\'werkzeug\')}"" in out')","(False, '""""""\nTest the base environment for Flask application.\n\nThis function tests that the remote address and user agent are correctly set\nwhen making a GET request to the root URL of the Flask application. It uses\nthe Werkzeug library to get the user agent string, which is used in the test.\n""""""\n\ndef test_environ_base_default(app, client):')","(False, '""""""\nFlask Request Data Retrieval Function\n\nThis function retrieves and stores relevant data from the Flask request object.\n\n### Parameters\n\nNone\n\n### Returns\n\nAn empty string, indicating successful retrieval of data.\n\n### Notes\n\n- This function sets two variables in the `g` object: `remote_addr` and `user_agent`, which contain the client\'s IP address and user agent string respectively.\n- The retrieved data is not stored anywhere; it is only temporarily set in the `g` object for potential future use.')","(True, '""""""\nTest the base environment of a Flask application.\n\nThis function tests that the remote address and user agent are correctly\nmodified in the request context when using the `client` object to make a\nrequest to the root URL of the application. It verifies that these values\nare set in the `flask.g` dictionary, which is used by Flask to store\ncontext data.\n\nParameters:\napp (Flask): The Flask application instance.\nclient: An object providing a way to interact with the application\'s\n    request context.\n\nReturns:\nNone\n\nRaises:\nAssertionError: If any of the assertions fail.\n""""""')","(False, '""""""\nFlask Request Data Retrieval Function\n\nThis function retrieves and stores relevant data from the Flask request object.\n\n### Parameters\n\nNone\n\n### Returns\n\nAn empty string, indicating successful retrieval of data.\n\n### Notes\n\n- This function sets two variables in the `g` object: `remote_addr` and `user_agent`, which contain the client\'s IP address and user agent string respectively.\n- The retrieved data is not stored anywhere; it is only temporarily set in the `g` object for potential future use.')"


"(True, '""""""\nReturns the value of the requested attribute, or raises an AttributeError if it does not exist.\n\nThe function is used to handle special attributes that are deprecated and will be removed in future versions of Flask.\nIt provides a way to access these attributes while still raising a warning about their deprecation.\n\nAttributes:\n    - `_app_ctx_stack`: The application context stack. (Deprecated)\n    - `_request_ctx_stack`: The request context stack. (Deprecated)\n    - `escape`: A function for escaping HTML characters. (Deprecated, use markupsafe.escape instead)\n    - `Markup`: A class for representing unescaped HTML. (Deprecated, use markupsafe.Markup instead)\n    - `signals_available`: Always returns True, as signals are always available.\n\nRaises:\n    AttributeError: If the requested attribute does not exist.\n""""""')"



"(True, '""""""\nReturns the version of Flask.\n\nThis function is deprecated and will be removed in Flask 3.1.\nInstead, use feature detection or \'importlib.metadata.version(""flask"")\'.\n\nArgs:\n    name (str): The attribute being accessed.\n\nReturns:\n    t.Any: The version of Flask as a string.\n\nRaises:\n    AttributeError: If the attribute does not exist.\n""""""')"








